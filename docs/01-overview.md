Grove Flow is a command-line tool for managing local, Markdown-based development workflows. All state is stored in version-controlled plain text files: plans are directories of `.md` files, and job status is defined by YAML frontmatter. It is designed for terminal-native use, providing CLIs and TUIs for management and using `tmux` for agent execution environments. It does not rely on a database or a cloud service.

## Key Features

*   **Job Types**: Defines several job types, each with a specific execution model:
    *   `chat`: An interactive, multi-turn conversation with an LLM, stored in a single Markdown file.
    *   `oneshot`: A single-turn request to an LLM for tasks like code generation or summarization.
    *   `interactive_agent`: An agent session that runs in a dedicated `tmux` window for user interaction.
    *   `headless_agent`: A non-interactive agent that carries out a job and then exits.
    *   `shell`: A command executed in the system's default shell.
    *   `file`: A non-executable job used to store reference content.
*   **Worktree Isolation**: Creates git worktrees in a `.grove-worktrees/` directory at the repository root for filesystem isolation. It can also create multi-repo worktrees to enable isolated changes across interdependent repositories.
*   **Dependency Orchestration**: Jobs declare dependencies on other jobs via the `depends_on` field in their frontmatter. The orchestrator reads these declarations to build a dependency graph and execute jobs in the correct order. This enables controlled context sharing between steps.
*   **Lifecycle Management**: Provides commands to manage a plan's lifecycle from creation (`flow init`), through review (`flow review`), to cleanup (`flow finish`).

## How It Works

A "plan" is a directory containing numbered Markdown files (e.g., `01-setup.md`, `02-implement.md`). Each file represents a "job" and contains YAML frontmatter that defines its properties, including `type`, `status`, and `depends_on`.

When a command like `flow run` is executed, an orchestrator reads all job files in the plan directory, builds an in-memory dependency graph, and identifies runnable jobs. It then executes these jobs using the appropriate executor for their type. This process creates a version-controllable audit trail for a plan's execution:
*   Specifications and context definitions are captured in plain text.
*   Outputs, such as LLM responses and agent transcripts (from Claude Code, Codex, and OpenCode), are appended back to the corresponding `.md` job file. This creates a persistent, reviewable record of development history.

## LLM Provider & Context Support

Grove Flow integrates with `grove-anthropic` and `grove-gemini` to support models from both providers.

*   **File Uploads**: Instead of inlining large amounts of context into the prompt, the tool uses provider-native file upload APIs. This allows jobs to use large context windows by attaching files such as repository context (`.grove/context`), the outputs of dependency jobs, and other curated contexts.
*   **Model Configuration**: The `model` can be configured in job frontmatter, with defaults inherited from plan configuration (`.grove-plan.yml`) and global user settings (`grove.yml`).
*   **Generation Parameters**: Generation parameters such as `temperature`, `top_p`, `top_k`, and `max_output_tokens` can be specified in job frontmatter.

## Ecosystem Integration

Grove Flow executes other command-line tools and uses library code from other parts of the Grove ecosystem as part of its operation:

*   **`grove-notebook` (`nb`)**: Plan initialization hooks can execute `nb` commands to create plans from notes. The notebook system acts as a separate store for development artifacts, independent of the main project repository. `flow` can also be configured to automatically preserve markdown files generated by Claude Code's "Plan Mode" into an executable job graph.
*   **`grove-context` (`cx`)**: Before executing `oneshot` or `chat` jobs, this tool is used to generate a context file based on `.grove/rules`. Context rules files can be saved and stored for different areas of focus.
*   **`grove-hooks`**: Running agent sessions are registered with the `grove-hooks` session registry (`~/.grove/hooks/sessions/`), which independently tracks process IDs and agent status (e.g., `idle`, `running`). The `grove-hooks tui` command provides a TUI for viewing all sessions, running jobs, and pending chat jobs.
*   **`grove-tmux` (`gmux`)**: Worktrees created by `flow` can be navigated using `grove-tmux`'s `sessionizer` subcommand, which provides Harpoon-inspired, single-key navigation. The key manager TUI allows binding repositories and worktrees to hotkeys, and `history` subcommand provides quick access to recent workspaces. Agent jobs are launched in new, named windows within a `tmux` session, which can be navigated with the `windows` subcommand.
*   **Agent CLIs**: Interactive agent jobs launch `claude`, `codex`, or `opencode` as subprocesses.

## Terminal & Editor Integration

*   **Starship**: Includes a prompt module (`flow starship`) that displays the active `flow` plan and a summary of job statuses (e.g., `my-plan [✓3 ●1 ○2]`) in the shell prompt.
*   **Neovim**: Chat jobs can be executed from within Neovim, facilitating interactive sessions with large context models.

## Advanced Usage & Automation

As a command-line tool, `flow` can be executed by other processes, including agents. An agent, guided by a "skill", can use `flow` to construct and execute its own development pipelines. This enables workflows such as using multi-step `oneshot` jobs with repository context for planning before carrying out an implementation.

Using Grove's "ecosystem" model, `flow` can create worktrees that span multiple repositories, allowing agents to perform coordinated and isolated changes across a set of interdependent projects.

## Installation

Install via the Grove meta-CLI:
```bash
grove install flow
```

Verify installation:
```bash
flow version
```

This requires the `grove` meta-CLI. See the Grove installation guide if it is not installed.
