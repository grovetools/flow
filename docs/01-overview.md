Grove Flow is a command-line tool for managing local, Markdown-based development workflows. All state is stored in version-controlled plain text files: plans are directories of `.md` jobs, and status is defined by YAML frontmatter. It is designed for terminal-native use with `tmux` for execution environments and does not rely on a database or a cloud service.

## Key Features

*   **Job Types**: Defines several job types, each with a specific execution model:
    *   `chat`: An interactive, multi-turn conversation with an LLM, stored in a single Markdown file.
    *   `oneshot`: A single-turn request to an LLM for tasks like code generation or summarization.
    *   `interactive_agent`: An interactive coding agent session that runs in a dedicated `tmux` window.
    *   `headless_agent`: A non-interactive agent that carries out a job and then exits.
    *   `shell`: A command executed in the system's default shell.
    *   `file`: A non-executable job used to store reference content.
*   **Worktree Isolation**: Creates git worktrees in a `.grove-worktrees/` directory at the repository root for filesystem isolation. It can also create multi-repo worktrees to enable isolated changes across interdependent repositories.
*   **Dependency Orchestration**: Jobs declare dependencies on other jobs via the `depends_on` field in their frontmatter. The orchestrator reads these declarations to build a dependency graph and execute jobs in the correct order. This enables controlled context sharing between steps.
*   **Lifecycle Management**: Provides commands to manage a plan's lifecycle from creation (`flow init`), through review (`flow review`), to cleanup (`flow finish`).

## How It Works

A "plan" is a directory containing numbered Markdown files (e.g., `01-setup.md`, `02-implement.md`). Each file represents a "job" and contains YAML frontmatter that defines its properties, including `type`, `status`, and `depends_on`.

When a command like `flow run` is executed, an orchestrator reads all job files in the plan directory, builds an in-memory dependency graph, and identifies runnable jobs. It then executes these jobs using the appropriate executor for their type. This process creates an audit trail for a plan's execution:
*   Specifications and context definitions can be captured in version control.
*   Outputs, such as LLM responses and agent transcripts (from Claude Code, Codex, and OpenCode), are appended back to the corresponding `.md` job file. This creates a persistent, reviewable record of development history.

## Ecosystem Integration

Grove Flow executes other command-line tools and uses library code from other parts of the Grove ecosystem as part of its operation:

*   **`grove-notebook` (`nb`)**: Plan initialization hooks can execute `nb` commands to create plans from notes. The notebook acts as a separate store for development artifacts, independent of the main project repository. `flow` can also be configured to automatically preserve markdown files generated by Claude Code's "Plan Mode" into an executable job graph.
*   **`grove-context` (`cx`)**: Before executing `oneshot` or `chat` jobs, this tool can be used to generate a context file based on `.grove/rules`.
*   **`grove-hooks`**: Running agent sessions are registered with the `grove-hooks` session registry, which independently tracks the process ID and agent status (e.g., `idle`, `running`).
*   **`grove-tmux`**: Worktrees created by `flow` can be navigated using `grove-tmux`, which can dynamically bind workspaces to `tmux` hotkeys. Agents are launched in new, named windows within a `tmux` session.
*   **Agent CLIs**: Interactive agent jobs launch `claude`, `codex`, or `opencode` as subprocesses.

## Terminal & Editor Integration

*   **Starship**: Includes a prompt module that displays the active `flow` plan and a summary of job statuses (e.g., completed, pending, running) in the shell prompt.
*   **Neovim**: Chat jobs can be executed from within Neovim, facilitating interactive sessions with large context models like Gemini 2.5 Pro, Sonnet, etc.

## Advanced Usage & Automation

As a command-line tool, `flow` can be executed by other processes, including agents. An agent, guided by a "skill", can use `flow` to construct and execute its own development pipelines. This enables workflows such as using multi-step `oneshot` jobs with repository context for planning before carrying out an implementation.

Using Grove's "ecosystem" model, `flow` can create worktrees that span multiple repositories, allowing agents to perform coordinated and isolated changes across a set of interdependent projects.

## Installation

Install via the Grove meta-CLI:
```bash
grove install flow
```

Verify installation:
```bash
flow version
```

This requires the `grove` meta-CLI. See the Grove installation guide if it is not installed.
