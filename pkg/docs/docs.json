{
  "sections": {
    "chats": {
      "title": "Chats",
      "content": "Grove Flow includes `flow chat` commands for managing conversational workflows with LLMs. This provides an environment for exploration and problem-solving before creating a structured, multi-step plan.",
      "subsections": [
        {
          "title": "The Chat Workflow",
          "content": "Chats are distinct from plans. Plans consist of interdependent jobs designed for structured execution, while chats are single Markdown files designed for interactive, back-and-forth conversation.\n\n| Feature       | `flow plan`                                    | `flow chat`                                        |\n|---------------|------------------------------------------------|----------------------------------------------------|\n| **Purpose**   | Structured execution, automation               | Exploration, ideation, refinement, problem-solving |\n| **Structure** | A directory of interdependent job files (a DAG) | A single Markdown file capturing a linear conversation |\n| **Execution** | Orchestrator runs jobs based on dependencies   | User and LLM respond sequentially in the same file   |\n\nA common workflow is to start with a `chat` to explore a concept, then use `flow plan extract` to convert parts of the conversation into an executable `plan`."
        },
        {
          "title": "Starting and Managing Chats",
          "content": "Conversations are managed as Markdown files. Their location is determined by the `notebooks` configuration in `grove.yml`, falling back to the `flow.chat_directory` setting for backward compatibility.\n\n### Initializing a Chat\n\nAny Markdown file can be converted into a chat job. The initialization command adds the necessary YAML frontmatter to the file.\n\n\nThis command adds the following frontmatter to `chats/new-api-idea.md`:\n\n\nYou can override the default title and model during initialization:\n\n\n### Continuing a Conversation\n\nTo have the LLM respond to your latest message, use `flow chat run`. This command scans for chat files where the last turn was from a \"user\" and generates the next LLM response, appending it to the file.\n\n\nAfter running, the file is updated with the LLM's response, ready for your next input.\n\n### Listing Chats\n\nTo see all available chats and their current status, use `flow chat list`.\n\n\n**Example Output:**\n\n\nYou can filter by status:",
          "code_blocks": [
            "# Create a markdown file\ntouch ./chats/new-api-idea.md\n\n# Initialize it as a chat job\nflow chat -s ./chats/new-api-idea.md",
            "---\nid: job-a1b2c3d4\ntitle: new-api-idea\ntype: chat\nmodel: gemini-2.5-pro # Inherited from config\nstatus: pending_user\nupdated_at: \"2025-09-26T10:00:00Z\"\naliases: []\ntags: []\n---\n\n# My API Idea",
            "flow chat -s ./chats/new-api-idea.md --title \"API Design\" --model \"claude-4-sonnet\"",
            "# Run all chats that are waiting for an LLM response\nflow chat run\n\n# Run a specific chat by its title\nflow chat run \"API Design\"",
            "flow chat list",
            "TITLE             STATUS        MODEL             FILE\nAPI Design        pending_user  claude-4-sonnet   new-api-idea.md\nold-feature       completed     gemini-2.0-flash  old-feature.md",
            "flow chat list --status pending_user"
          ]
        },
        {
          "title": "Context in Chat Sessions",
          "content": "When `flow chat run` is executed, it uses `grove-context` to gather file context based on rules defined in your project's `.grove/rules` file. This context is included in the request to the LLM, providing it with relevant information from your codebase."
        },
        {
          "title": "From Conversation to Execution",
          "content": "`chat` jobs are for conversation; their output is text. To execute code or run commands, content from a chat must be extracted into a `plan` containing an `agent` or `shell` job. An `interactive_agent` job created from a chat can then be run, which will launch a `tmux` session for development.\n\nThere is no `flow chat launch` command. The workflow involves extracting content into a plan first."
        },
        {
          "title": "Extracting Plans from Chats",
          "content": "The `flow plan extract` command converts parts of a conversation into new jobs within a plan.\n\n### Listing Extractable Blocks\n\nEach LLM response in a chat file is tagged with a unique ID inside a `\u003c!-- grove: ... --\u003e` comment. You can list all extractable blocks within a file.\n\n\n**Example Output:**\n\n\n### Creating a Job from a Block\n\nUsing a block ID, you can create a new job in a plan directory. The new job does not contain the extracted content directly; instead, it contains a `source_block` reference. The content is resolved and injected into the prompt when the job is executed.\n\n\nThis creates a new chat job in the `api-implementation` plan. The job file will contain a reference like `source_block: chats/new-api-idea.md#e5f6g7h8`.\n\nYou can also extract the entire body of a chat file using the `all` keyword:\n\n\nThis creates a job with a `source_block: chats/new-api-idea.md` reference.",
          "code_blocks": [
            "flow plan extract list --file ./chats/new-api-idea.md",
            "Found 2 extractable blocks in chats/new-api-idea.md:\n\nID: a1b2c3d4\nType: llm\nLine: 10\nPreview: Here is a proposed API structure...\n---\nID: e5f6g7h8\nType: llm\nLine: 45\nPreview: The database schema could look like this...\n---",
            "# First, ensure a plan exists\nflow plan init api-implementation --worktree\n\n# Extract a block into the new plan\nflow plan extract e5f6g7h8 --file ./chats/new-api-idea.md --title \"Implement API Schema\"",
            "flow plan extract all --file ./chats/new-api-idea.md --title \"Full API Discussion\""
          ]
        },
        {
          "title": "Chat Configuration",
          "content": "Chat behavior is configured in your project's `grove.yml` file under the `flow` key.\n\n\nYou can override the model for a specific chat by setting the `model` key in the chat file's frontmatter.",
          "code_blocks": [
            "# .grove/config.yml or grove.yml\nflow:\n  # Directory where chat markdown files are stored.\n  # This is superseded by the `notebooks` configuration if present.\n  chat_directory: ./chats\n  \n  # Default model for oneshot and chat jobs\n  oneshot_model: gemini-2.5-pro"
          ]
        },
        {
          "title": "Use Cases and Examples",
          "content": "Chats are suitable for exploratory and iterative scenarios.\n\n*   **Brainstorming**: Explore different approaches to a new feature.\n*   **Problem Exploration**: Work through a bug with an LLM, providing logs and code snippets.\n*   **Prototyping**: Ask an LLM to generate boilerplate code or a proof-of-concept.\n*   **Documentation**: Draft an outline for new documentation.\n\n### Example Workflow: From Idea to Plan\n\n1.  **Start a chat:**\n    ```bash\n    echo \"# Idea: Refactor auth service\" \u003e chats/auth-refactor.md\n    flow chat -s chats/auth-refactor.md\n    ```\n\n2.  **Add an initial prompt to the file, then run the chat to get an LLM response:**\n    ```bash\n    # (Edit chats/auth-refactor.md to add details)\n    flow chat run auth-refactor\n    ```\n\n3.  **After a few turns, you have a solid plan from the LLM. List the extractable blocks:**\n    ```bash\n    flow plan extract list --file chats/auth-refactor.md\n    # Output shows block ID: a1b2c3\n    ```\n\n4.  **Create a new plan and extract the final LLM response into an `interactive_agent` job:**\n    ```bash\n    flow plan init refactor-auth-service --worktree\n    flow plan add refactor-auth-service -t interactive_agent --title \"Refactor Auth Service\"\n    # This creates a new job, e.g., 01-refactor-auth-service.md\n\n    # Now, extract the chat content into that job.\n    # We can do this by setting the source_block property. For now, this is a manual edit.\n    # An alternative is to use `plan extract` and then change the job type.\n    flow plan extract a1b2c3 --file ./chats/auth-refactor.md --title \"Implement Auth Refactor\"\n    # This creates a new chat job in the plan. Manually change `type: chat` to `type: interactive_agent`.\n    ```\n\n5.  **Run the new agent job to start a coding session:**\n    ```bash\n    flow plan run refactor-auth-service/01-implement-auth-refactor.md\n    ```"
        }
      ]
    },
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a reference for the `flow` command-line interface, covering all subcommands and their options.",
      "subsections": [
        {
          "title": "`flow plan`",
          "content": "Manages multi-step orchestration plans.\n\n### `flow plan init`\n\nInitializes a new plan directory.\n\n**Syntax**\n\n\n**Description**\n\nCreates a new plan in the specified directory, including a `.grove-plan.yml` file for default configuration. Running the command without a directory name or with the `-t` flag launches an interactive terminal interface to guide plan creation.\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--extract-all-from` | | Path to a markdown file to extract all content into an initial job. | |\n| `--force` | `-f` | Overwrite the destination directory if it already exists. | `false` |\n| `--model` | | Default model for jobs in this plan (e.g., `gemini-2.5-pro`). | (none) |\n| `--note-ref` | | Path to a source note to link to this plan for lifecycle hooks. | |\n| `--open-session` | | Immediately open a tmux session for the plan's worktree. | `false` |\n| `--recipe` | | Initialize the plan from a pre-defined recipe template. | (none) |\n| `--recipe-cmd` | | Command that outputs JSON recipe definitions, overriding `grove.yml`. | |\n| `--recipe-vars` | | Variables for recipe templates (`key=value`). Can be used multiple times. | (none) |\n| `--repos` | | Specific repos to include in an ecosystem worktree. | (all submodules) |\n| `--target-agent-container` | | Default container for agent jobs in the plan. | (none) |\n| `--tui` | `-t` | Launch an interactive TUI to create a new plan. | `false` |\n| `--worktree` | | Set a default worktree. If no name is provided, uses the plan directory name. | (none) |\n\n**Examples**\n\n\n### `flow plan add`\n\nAdds a new job to a plan.\n\n**Syntax**\n\n\n**Description**\n\nAdds a new job file to a plan directory. If no directory is specified, it uses the active plan. The command can be run interactively or non-interactively with flags.\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--agent-continue` | | Continue the last agent session (adds `--continue` flag). | `false` |\n| `--depends-on` | `-d` | List of job filenames this job depends on. | (none) |\n| `--interactive` | `-i` | Launch an interactive TUI to create the new job. | `false` |\n| `--output-type` | | Output type: `file`, `commit`, `none`, or `generate_jobs`. | `file` |\n| `--prepend-dependencies` | | Inline dependency content into the prompt body. | `false` |\n| `--prompt` | `-p` | Inline prompt text for the job. | (from stdin) |\n| `--prompt-file` | `-f` | Path to a file containing additional prompt text. | (none) |\n| `--source-files` | | Comma-separated list of source files for context. | (none) |\n| `--template` | | Name of a job template to use. | (none) |\n| `--title` | | Title of the job. | (required) |\n| `--type` | `-t` | Job type: `agent`, `interactive_agent`, `headless_agent`, `oneshot`, `shell`, `chat`. | `agent` |\n| `--worktree` | | Explicitly set the worktree for this job. | (plan default) |\n\n**Examples**\n\n\n### `flow plan list`\n\nLists all plans in the configured directory or across workspaces.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--all-workspaces` | | List plans across all discovered workspaces. | `false` |\n| `--include-finished` | | Include plans marked as \"finished\". | `false` |\n| `--show-hold` | | Include plans marked as \"hold\". | `false` |\n| `--verbose` | `-v` | Show detailed information for each plan. | `false` |\n\n### `flow plan tui`\n\nLaunches an interactive terminal interface for browsing and managing plans.\n\n**Syntax**\n\n\n### `flow plan set`, `current`, `unset`\n\nManage the active plan for the current context.\n\n**Syntax**\n\n\n### `flow plan status`\n\nShows the status of all jobs in a plan.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--format`| `-f` | Output format: `tree`, `list`, `json`. | `tree` |\n| `--graph` | `-g` | Show a dependency graph in Mermaid syntax. | `false` |\n| `--tui` | `-t` | Launch an interactive terminal interface status view. | `false` |\n| `--verbose`| `-v` | Show detailed job information. | `false` |\n\n### `flow plan graph`\n\nVisualizes the job dependency graph.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--format` | `-f` | Output format: `mermaid`, `dot`, `ascii`. | `mermaid` |\n| `--output` | `-o` | Output file path (defaults to stdout). | (stdout) |\n| `--port` | `-p` | Port for the web server when using `--serve`. | `8080` |\n| `--serve` | `-s` | Serve an interactive HTML visualization. | `false` |\n\n### `flow plan run`\n\nRuns jobs in a plan.\n\n**Syntax**\n\n\n**Description**\n\nExecutes jobs in an orchestration plan. Without arguments, it runs the next available jobs based on dependencies. It can also run one or more specified job files.\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--all` | `-a` | Run all pending jobs in the plan sequentially. | `false` |\n| `--model` | | Override the LLM model for this run. | (none) |\n| `--next` | `-n` | Run the next available jobs. (This is the default) | `false` |\n| `--parallel` | `-p` | Maximum number of jobs to run in parallel. | `3` |\n| `--skip-interactive` | | Skip any interactive agent jobs. | `false` |\n| `--watch` | `-w` | Watch plan progress in real-time. | `false` |\n| `--yes` | `-y` | Skip all confirmation prompts. | `false` |\n\n### `flow plan complete`\n\nMarks a job as completed.\n\n**Syntax**\n\n\n**Description**\n\nManually marks a job's status as `completed`. This is useful for interactive jobs or when an external process has finished a task. It also cleans up associated resources like tmux windows.\n\n### `flow plan open`\n\nOpens a plan's worktree in a dedicated tmux session.\n\n**Syntax**\n\n\n**Description**\n\nSwitches to or creates a tmux session for the plan's associated worktree and opens the interactive status TUI. A default worktree must be set in the plan's configuration.\n\n### `flow plan finish`\n\nGuides through the process of finishing and cleaning up a plan.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--archive` | | Archive the plan directory. | `false` |\n| `--clean-dev-links` | | Clean up development binary links from the worktree. | `false` |\n| `--close-session` | | Close the associated tmux session. | `false` |\n| `--delete-branch` | | Delete the local git branch. | `false` |\n| `--delete-remote` | | Delete the remote git branch. | `false` |\n| `--force` | | Force git operations (e.g., deleting unmerged branches). | `false` |\n| `--prune-worktree` | | Remove the git worktree directory. | `false` |\n| `--rebuild-binaries` | | Rebuild binaries in the main repository. | `false` |\n| `--yes` | `-y` | Automatically confirm all cleanup actions. | `false` |\n\n### `flow plan config`\n\nGets or sets configuration values in a plan's `.grove-plan.yml`.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Description |\n| :--- | :--- |\n| `--get` | Get a specific configuration value by key. |\n| `--set` | Set a configuration value (e.g., `key=value`). |\n| `--json` | Output the configuration in JSON format. |\n\n### `flow plan context`\n\nManages job-specific context rules.\n\n**Syntax**\n**Description**\nSaves the current active `.grove/rules` file as a job-specific context rules file and updates the job's frontmatter to reference it.\n\n### `flow plan extract`\n\nExtracts content from a chat or markdown file into a new job.\n\n**Syntax**\n\n\n**Description**\n\n`list`: Lists all extractable block IDs in the source file.\n`all`: Extracts all content below the frontmatter into a single new job.\n`\u003cblock-id...\u003e`: Extracts one or more specific blocks into a new job.\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--depends-on` | `-d` | Dependencies for the new job. | (none) |\n| `--file` | | Source markdown file to extract from. | `plan.md` |\n| `--model` | | LLM model for the new job. | (plan default) |\n| `--output` | | Output type for the new job. | `file` |\n| `--title` | | Title for the new job (required for extract). | |\n| `--worktree` | | Worktree for the new job. | (plan default) |\n| `--json` | | Output block list in JSON format (for `list` command). | `false` |\n\n### `flow plan templates list`\n\nLists available job templates from built-in, user (`~/.config/grove/job-templates`), and project (`.grove/job-templates`) sources.\n\n**Syntax**\n\n\n### `flow plan recipes list`\n\nLists available plan recipes from built-in, user, and dynamic sources.\n\n**Syntax**\n\n\n### `flow plan jobs`\n\nManages individual jobs within a plan.\n\n**Subcommands**\n\n- `list`: Lists available job types (e.g., `agent`, `oneshot`).\n- `rename \u003cjob-file\u003e \u003cnew-title\u003e`: Renames a job file and title, and updates all dependent jobs.\n- `update-deps \u003cjob-file\u003e [dependency-files...]`: Replaces a job's `depends_on` list with the provided files.\n\n### `flow plan hold` / `unhold`\n\nSets or clears a plan's `hold` status, which hides it from default list views.\n\n**Syntax**\n\n### `flow plan review`\n\nMarks a plan as ready for review and executes `on_review` hooks.\n\n**Syntax**\n\n### `flow plan step`\n\nSteps through plan execution interactively.\n\n**Syntax**\n\n\n---",
          "code_blocks": [
            "flow plan init \u003cdirectory\u003e [flags]",
            "# Initialize a new plan in the 'new-feature' directory\nflow plan init new-feature\n\n# Initialize a plan and create an associated git worktree\nflow plan init new-feature --worktree\n\n# Initialize from a recipe with variables\nflow plan init user-auth --recipe standard-feature --recipe-vars \"model=gemini-2.5-pro\"",
            "flow plan add [directory] [flags]",
            "# Add a new agent job to the active plan interactively\nflow plan add -i\n\n# Add a shell job to 'my-plan' that depends on a previous job\nflow plan add my-plan -t shell -p \"npm install\" -d \"01-setup.md\" --title \"Install Dependencies\"\n\n# Add a job using a template and source files for context\nflow plan add --template code-review --source-files src/main.go --title \"Review Main Logic\"",
            "flow plan list [flags]",
            "flow plan tui",
            "flow plan set \u003cplan-directory\u003e\nflow plan current\nflow plan unset",
            "flow plan status [directory] [flags]",
            "flow plan graph [directory] [flags]",
            "flow plan run [job-file...] [flags]",
            "flow plan complete \u003cjob-file\u003e",
            "flow plan open [directory]",
            "flow plan finish [directory] [flags]",
            "flow plan config [directory] [flags]",
            "flow plan context set \u003cjob-file\u003e",
            "flow plan extract \u003cblock-id... | all | list\u003e --file \u003csource-file\u003e --title \u003cnew-job-title\u003e [flags]",
            "flow plan templates list",
            "flow plan recipes list",
            "flow plan hold [directory]\nflow plan unhold [directory]",
            "flow plan review [directory]",
            "flow plan step [directory]"
          ]
        },
        {
          "title": "`flow chat`",
          "content": "Manages conversational, multi-turn AI interactions.\n\n### `flow chat` (initialize)\n\nInitializes a markdown file as a runnable chat job by adding frontmatter.\n\n**Syntax**\n\n**Flags**\n\n| Flag | Shorthand | Description |\n| :--- | :--- | :--- |\n| `--spec-file` | `-s` | Path to a markdown file to convert into a chat job (required). |\n| `--title` | `-t` | Title for the chat job (defaults to filename). |\n| `--model` | `-m` | LLM model to use for the chat. |\n\n### `flow chat list`\n\nLists all chat jobs in the configured chat directory.\n\n**Syntax**\n\n**Flags**\n\n| Flag | Description |\n| :--- | :--- |\n| `--status` | Filter chats by status (e.g., `pending_user`, `completed`). |\n\n### `flow chat run`\n\nRuns outstanding chat jobs that are waiting for an LLM response.\n\n**Syntax**\n\n\n**Description**\n\nScans the chat directory for jobs where the last turn is from a user and runs them to generate the next LLM response. If titles are provided, only those specific chats are run.\n\n---",
          "code_blocks": [
            "flow chat -s \u003cfile.md\u003e [flags]",
            "flow chat list [flags]",
            "flow chat run [title...]"
          ]
        },
        {
          "title": "`flow models`",
          "content": "Lists available LLM models.\n\n**Syntax**\n\n\n**Description**\n\nDisplays a list of recommended LLM models that can be used in job and chat frontmatter.\n\n---",
          "code_blocks": [
            "flow models [--json]"
          ]
        },
        {
          "title": "`flow tmux`",
          "content": "Manages `flow` within tmux windows.\n\n### `flow tmux status`\n\nOpens the plan status TUI in a dedicated tmux window.\n\n**Syntax**\n**Flags**\n\n| Flag | Description | Default |\n| :--- | :--- | :--- |\n| `--window-name` | Name for the new tmux window. | `plan` |\n| `--window-index` | Index (position) for the new window. | `2` |\n\n---",
          "code_blocks": [
            "flow tmux status [directory] [flags]"
          ]
        },
        {
          "title": "`flow version`",
          "content": "Prints version information for the `flow` binary.\n\n**Syntax**\n\n\n---",
          "code_blocks": [
            "flow version [--json]"
          ]
        },
        {
          "title": "Global Options",
          "content": "| Flag | Description |\n| :--- | :--- |\n| `--config` | Path to a custom `grove.yml` configuration file. |\n| `--json` | Output command results in JSON format. |\n| `--verbose`| Enable verbose logging output. |\n| `--help` | Display help for any command. |\n\n---"
        },
        {
          "title": "Environment Variables",
          "content": "- `GROVE_ECOSYSTEM_ROOT`: Specifies the root directory of Grove ecosystem repositories, used to locate shared resources.\n- `GROVE_FLOW_SKIP_DOCKER_CHECK`: If set to `true`, skips pre-flight checks for the Docker daemon (used in testing).\n- `GROVE_CONFIG`: Specifies a path to a custom `grove.yml` configuration file.\n\n---"
        },
        {
          "title": "Configuration Files",
          "content": "- **`grove.yml`**: The main project-level configuration file. `flow` settings are placed under the `flow:` key.\n- **`.grove-plan.yml`**: A plan-specific configuration file located inside a plan directory. Values here override the project-level `grove.yml`.\n- **`.grove/state.yml`**: A local file that stores the active plan for the current directory or worktree context. This file should not be committed to version control."
        }
      ]
    },
    "configuration": {
      "title": "Configuration",
      "content": "Grove Flow configuration is managed through YAML files at the project level (`grove.yml`) and the plan level (`.grove-plan.yml`). This allows for project-wide defaults with plan-specific overrides.",
      "subsections": [
        {
          "title": "Project-Level Configuration (`grove.yml`)",
          "content": "Global defaults for Grove Flow are set under the `flow` key in the project's `grove.yml` file.\n\n\n### Core Settings\n\n-   `plans_directory` **(Deprecated)**: Previously specified the storage directory for plans. This setting is now superseded by the `notebooks` configuration in `grove.yml`, which provides a more unified way to manage plans, chats, and notes.\n-   `chat_directory` **(Deprecated)**: Previously defined the location for standalone chat files. This is also now managed by the `notebooks` configuration.\n-   `oneshot_model`: Sets the default LLM model for `oneshot` and `chat` jobs. This value is used if no model is specified in the plan or job frontmatter.\n-   `target_agent_container`: Specifies the default Docker container image for `agent` and `interactive_agent` jobs.\n-   `max_consecutive_steps`: An integer that sets the maximum number of non-interactive jobs the orchestrator will run sequentially before halting. This prevents runaway executions. Defaults to 20.\n\n### Summarization Settings\n\n-   `summarize_on_complete`: A boolean (`true` or `false`) that enables or disables automatic job summarization when a job is marked as completed via `flow plan complete`.\n-   `summary_model`: The LLM model used to generate job summaries.\n-   `summary_prompt`: A custom prompt template for summarization. It must include a `%s` placeholder where the job content will be inserted.\n-   `summary_max_chars`: An integer defining the maximum character length for a generated summary.\n\n### Recipe Configuration\n\nThe `recipes` section configures how `flow plan init --recipe` behaves:\n\n-   `get_recipe_cmd`: An optional command that outputs a JSON definition of available recipes, allowing for dynamic recipe loading from external sources.\n-   `vars`: Under a specific recipe name (e.g., `docgen-customize`), this key defines default variables for that recipe's templates. These can be overridden at initialization time with the `--recipe-vars` flag.",
          "code_blocks": [
            "# Example grove.yml\nflow:\n  # Default model for oneshot and chat jobs.\n  oneshot_model: gemini-2.5-pro\n  \n  # Default container image for agent jobs.\n  target_agent_container: grove-agent-ide\n\n  # Maximum consecutive non-interactive steps before the orchestrator halts.\n  # This acts as a safeguard against potential infinite loops. Default: 20\n  max_consecutive_steps: 50\n\n  # Configuration for job summarization on completion.\n  summarize_on_complete: true\n  summary_model: gemini-2.5-flash\n  summary_prompt: \"Provide a one-sentence summary of the outcome from the following job log, under 150 characters:\\n---\\n%s\"\n  summary_max_chars: 150\n\n  # Configuration for plan recipes.\n  recipes:\n    # (Optional) Command to execute for discovering dynamic recipes.\n    # The command should output a JSON object where keys are recipe names.\n    get_recipe_cmd: \"grove-recipes list --json\"\n    \n    # (Optional) Default variables for specific recipes.\n    # These can be overridden by the --recipe-vars flag during plan creation.\n    docgen-customize:\n      vars:\n        model: \"gemini-2.5-pro\""
          ]
        },
        {
          "title": "Plan-Level Configuration (`.grove-plan.yml`)",
          "content": "Each plan directory can contain a `.grove-plan.yml` file to specify settings that apply only to that plan, overriding any project-level defaults.\n\n\n### Plan-Specific Settings\n\n-   `model`: Overrides the `oneshot_model` from `grove.yml` for all jobs within this plan.\n-   `worktree`: Sets a default `worktree` for `agent`, `interactive_agent`, and `shell` jobs. This is automatically set by `flow plan init --worktree`.\n-   `target_agent_container`: Overrides the default container for agent jobs.\n-   `status`: Sets a lifecycle status for the plan.\n    -   `hold`: Hides the plan from default list views (`flow plan list`, `flow plan tui`).\n    -   `review`: Marks the plan as ready for final review before cleanup. Set via `flow plan review`.\n    -   `finished`: Marks the plan as complete. Set via `flow plan finish`.\n-   `repos`: For \"ecosystem worktrees\" in projects with submodules, this specifies which repositories to include when creating the worktree. If omitted, all submodules are included.\n-   `notes`: A string for user-defined notes about the plan, visible in the TUI.\n-   `prepend_dependencies`: A boolean (`true` or `false`) that sets the default for whether dependency content is inlined into a job's prompt. Can be overridden in individual jobs.\n-   `hooks`: Defines shell commands to run at specific plan lifecycle events (`on_start`, `on_review`, `on_finish`). Supports Go template variables like `{{.PlanName}}` and `{{.NoteRef}}`.",
          "code_blocks": [
            "# ./plans/my-feature-plan/.grove-plan.yml\n\n# Override the default model for all jobs in this plan.\nmodel: gemini-2.5-pro\n\n# Set a default worktree for all agent and shell jobs in this plan.\nworktree: feature/my-new-api\n\n# For ecosystem worktrees, specify which repositories to include.\n# If omitted, all submodules are included.\nrepos:\n  - grove-core\n  - grove-flow\n\n# Set a status to control visibility in commands like `flow plan list`.\n# Valid statuses: \"hold\", \"review\", \"finished\".\nstatus: hold\n\n# Default setting for whether dependency content should be inlined into prompts.\nprepend_dependencies: true\n\n# Plan-specific user notes, visible in the `flow plan tui`.\nnotes: \"API implementation for the new user profile service.\"\n\n# Hooks to execute at different lifecycle stages.\nhooks:\n  on_start: 'echo \"Plan {{.PlanName}} starting...\"'\n  on_review: 'nb move \"{{.NoteRef}}\" review --force'"
          ]
        },
        {
          "title": "Managing Plan Configuration",
          "content": "The `flow plan config` command reads and writes values to a plan's `.grove-plan.yml` file.\n\n-   **View current configuration:**\n    ```bash\n    flow plan config my-feature-plan\n    ```\n-   **Get a specific value:**\n    ```bash\n    flow plan config my-feature-plan --get model\n    ```\n-   **Set or update values:**\n    ```bash\n    flow plan config my-feature-plan --set model=gemini-2.5-pro --set worktree=feature/new\n    ```\n    When a value is set, this command also propagates the new value to any existing job files within the plan that do not already have that key defined in their frontmatter."
        },
        {
          "title": "Configuration Inheritance",
          "content": "Settings are resolved in the following order of precedence (highest to lowest):\n\n1.  **Job Frontmatter**: Values in a job's markdown file (`.md`).\n2.  **Plan-Level (`.grove-plan.yml`)**: Configuration in the plan's directory.\n3.  **Project-Level (`grove.yml`)**: Global configuration for the project.\n4.  **System Defaults**: Hardcoded fallbacks within the application."
        },
        {
          "title": "Environment Variables",
          "content": "-   `GROVE_CONFIG`: Specifies a path to a custom `grove.yml` file, overriding the default search behavior up the directory tree.\n-   `GROVE_ECOSYSTEM_ROOT`: A path to the root of a Grove ecosystem checkout, used to locate other Grove tools and shared resources.\n-   LLM provider API keys (e.g., `GEMINI_API_KEY`) are required for `grove-flow` to function but are managed by their respective tool configurations (e.g., `grove-gemini`)."
        },
        {
          "title": "Best Practices",
          "content": "-   Set project-wide defaults for `oneshot_model` and `target_agent_container` in the root `grove.yml` file.\n-   Use `.grove-plan.yml` to define a plan-specific `worktree` to make the plan self-contained and portable.\n-   Store LLM API keys in your shell environment or a secure keychain, not in version-controlled configuration files.\n-   Use `flow plan set \u003cplan-name\u003e` to make a plan active for the current repository or worktree. This avoids the need to specify the plan directory in every subsequent command. The active plan is stored locally in `.grove/state.yml`."
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "This document provides examples for using `grove-flow` for single- and multi-step development workflows.",
      "subsections": [
        {
          "title": "Example 1: Basic Plan Execution",
          "content": "This example covers creating a plan, adding a single job, and running it.\n\n1.  **Initialize the Plan**\n\n    Create a new plan directory and an associated Git worktree. The `--worktree` flag creates a Git worktree and branch named after the plan (`new-feature-endpoint`), which isolates file changes.\n\n    ```bash\n    flow plan init new-feature-endpoint --worktree\n    ```\n\n    This command creates the `new-feature-endpoint` directory, adds a `.grove-plan.yml` configuration file, and sets `new-feature-endpoint` as the active plan.\n\n2.  **Add an Agent Job**\n\n    Add a job to the active plan. The `agent` job type is for code generation tasks.\n\n    ```bash\n    flow plan add --title \"Implement User Endpoint\" --type agent \\\n      -p \"Create a new Go API endpoint at /api/v1/users for basic CRUD operations.\"\n    ```\n\n    This creates the file `new-feature-endpoint/01-implement-user-endpoint.md` containing the job's configuration and prompt.\n\n3.  **Check the Status**\n\n    View the plan's status using the interactive terminal UI (`-t`).\n\n    ```bash\n    flow plan status -t\n    ```\n\n    The TUI displays the \"Implement User Endpoint\" job with a `pending` status.\n\n4.  **Run the Plan**\n\n    Execute the next available job in the plan.\n\n    ```bash\n    flow plan run\n    ```\n\n    `grove-flow` finds the pending job and executes it in the `new-feature-endpoint` worktree."
        },
        {
          "title": "Example 2: Multi-Job Feature Workflow",
          "content": "`grove-flow` orchestrates multi-step workflows with dependencies. This example shows a development pattern of specification, implementation, and testing.\n\n1.  **Initialize the Plan**\n\n    Create a plan for a new user authentication feature.\n\n    ```bash\n    flow plan init user-auth-feature --worktree\n    ```\n\n2.  **Add a Specification Job**\n\n    The first step is a `oneshot` job for an LLM to write a technical specification. This job has no dependencies.\n\n    ```bash\n    flow plan add --title \"Define Authentication Spec\" --type oneshot \\\n      -p \"Write a technical specification for a JWT-based authentication system, including data models and API endpoints.\"\n    ```\n\n    This creates `user-auth-feature/01-define-authentication-spec.md`.\n\n3.  **Add an Implementation Job**\n\n    Next, add an `agent` job to implement the feature. The `-d` flag specifies that this job depends on the completion of the specification job.\n\n    ```bash\n    flow plan add --title \"Implement Auth Logic\" --type agent \\\n      -d \"01-define-authentication-spec.md\" \\\n      -p \"Implement the authentication logic based on the specification from the previous step.\"\n    ```\n\n    This creates `user-auth-feature/02-implement-auth-logic.md`. `grove-flow` will not run this job until `01-define-authentication-spec.md` is complete.\n\n4.  **Add a Testing Job**\n\n    Add another `agent` job to write tests, which depends on the implementation.\n\n    ```bash\n    flow plan add --title \"Write Unit Tests\" --type agent \\\n      -d \"02-implement-auth-logic.md\" \\\n      -p \"Write unit and integration tests for the authentication system.\"\n    ```\n\n    This creates `user-auth-feature/03-write-unit-tests.md`.\n\n5.  **Run the Workflow**\n\n    Execute all jobs in the plan according to their dependency order.\n\n    ```bash\n    flow plan run --all\n    ```\n\n    `grove-flow` runs the specification job first. Once it completes, it runs the implementation job, followed by the testing job."
        },
        {
          "title": "Example 3: Interactive Chat-to-Plan Workflow",
          "content": "The `chat` and `extract` commands are used to convert an unstructured conversation into an executable plan.\n\n1.  **Start a Chat**\n\n    Create a Markdown file for an idea and initialize it as a chat job. This adds the required frontmatter to the file.\n\n    ```bash\n    # Create a directory for chat files\n    mkdir -p chats\n\n    # Create the file\n    echo \"# Idea: Refactor the logging system\" \u003e chats/logging-refactor.md\n\n    # Initialize it as a runnable chat job\n    flow chat -s chats/logging-refactor.md\n    ```\n\n2.  **Iterate with the LLM**\n\n    Run the chat to get a response from the LLM. Each LLM response is automatically assigned a unique block ID.\n\n    ```bash\n    # Get the first response from the LLM\n    flow chat run logging-refactor\n    ```\n\n    After several turns, `chats/logging-refactor.md` might contain:\n\n    ```markdown\n    ---\n    title: Idea: Refactor the logging system\n    type: chat\n    ---\n    # Idea: Refactor the logging system\n\n    \u003c!-- grove: {\"id\": \"a1b2c3\"} --\u003e\n    ## LLM Response\n    A high-level plan for the logging refactor:\n    1.  Introduce a structured logging library.\n    2.  Define standardized log levels.\n    3.  Create a centralized logging configuration.\n\n    \u003c!-- grove: {\"template\": \"chat\"} --\u003e\n    That sounds good. Can you create a more detailed technical plan for step 1?\n\n    \u003c!-- grove: {\"id\": \"d4e5f6\"} --\u003e\n    ## LLM Response\n    For step 1, we will:\n    - Add a logging library to `go.mod`.\n    - Create a new package `internal/logging`.\n    - Implement a `NewLogger()` function.\n    ```\n\n3.  **Extract a Job from the Chat**\n\n    The LLM's second response (ID `d4e5f6`) can be extracted into a formal plan.\n\n    ```bash\n    # First, create a new plan to hold the extracted job\n    flow plan init logging-refactor-plan --worktree\n\n    # Now, extract the block from the chat into the active plan\n    flow plan extract d4e5f6 --title \"Implement Structured Logger\" \\\n      --file chats/logging-refactor.md\n    ```\n\n    This command finds the content of block `d4e5f6` and creates a new job file (`01-implement-structured-logger.md`) in the `logging-refactor-plan`. This job is now part of a formal workflow and can be executed with `flow plan run`."
        }
      ]
    },
    "managing-plans": {
      "title": "Managing Plans",
      "content": "Grove Flow uses \"Plans\" to organize and execute multi-step workflows. A plan is a directory that contains job files, configuration, and related artifacts. This document covers the commands used to create, manage, inspect, and clean up plans.",
      "subsections": [
        {
          "title": "Plan Initialization",
          "content": "The `flow plan init` command creates a plan directory and a default configuration file, `.grove-plan.yml`. The base name of the directory provided becomes the plan's identifier.\n\n### Basic Initialization\n\nTo create a new plan in the configured plans directory:\n\n\nThis creates the directory, adds a default `.grove-plan.yml` configuration file, and sets `new-feature-development` as the active plan.\n\n### Using Worktrees\n\nFor jobs that modify code, the `--worktree` flag creates an isolated Git worktree located in the repository's `.grove-worktrees/` directory.\n\n*   **Auto-named Worktree:** Using `--worktree` without a value creates a worktree and a branch with the same name as the plan.\n    ```bash\n    # Creates a worktree and branch named \"api-refactor\"\n    flow plan init api-refactor --worktree\n    ```\n*   **Custom-named Worktree:** To specify a different branch name, provide a value to the flag.\n    ```bash\n    # Creates a worktree and branch named \"feature/user-auth\"\n    flow plan init user-authentication --worktree=feature/user-auth\n    ```\n\n### Using Recipes\n\nRecipes are plan templates. The `--recipe` flag initializes a plan with a set of pre-defined job files from a built-in or custom recipe.\n\n\n### Extracting from Files\n\nA plan can be initialized from an existing file using `--extract-all-from`. This creates an initial job containing the body of the source file, which is useful for converting chat notes into an executable plan.\n\n\n### Combined Initialization\n\nInitialization flags can be combined to create more complex starting points for a plan.\n\n\n### Interactive TUI\n\nRunning `flow plan init` in a terminal without a directory argument, or with the `-t` flag, launches a terminal user interface (TUI) to guide through the creation of a new plan. The TUI provides options to name the plan, select a recipe, and configure worktree settings.",
          "code_blocks": [
            "flow plan init new-feature-development",
            "# Initializes a plan using the 'standard-feature' recipe\nflow plan init implement-caching --recipe standard-feature",
            "# Creates a plan with one job containing the content of notes.md\nflow plan init plan-from-notes --extract-all-from ./chats/notes.md",
            "flow plan init user-profile-api \\\n  --recipe standard-feature \\\n  --extract-all-from ./chats/api-discussion.md \\\n  --worktree"
          ]
        },
        {
          "title": "Listing and Browsing Plans",
          "content": "-   **`flow plan list`**: Displays a table of all plans found in the configured `plans_directory`. The output includes the number of jobs in each plan and a summary of their statuses.\n-   **`flow plan tui`**: Launches a terminal user interface for navigating plans. This interface allows for viewing plan details, opening a plan's specific status view, and managing the plan lifecycle (e.g., setting active, reviewing, finishing)."
        },
        {
          "title": "Active Plan Management",
          "content": "An \"active plan\" is a reference stored in a local `.grove/state.yml` file. It allows commands like `flow plan status` or `flow plan add` to operate on a plan without requiring the directory path to be specified in each command.\n\n-   **`flow plan set \u003cplan-directory\u003e`**: Sets the specified plan as active.\n    ```bash\n    flow plan set user-profile-api\n    ```\n-   **`flow plan current`**: Displays the name of the currently active plan.\n-   **`flow plan unset`**: Clears the active plan setting."
        },
        {
          "title": "Status and Visualization",
          "content": "The state of a plan and the relationships between its jobs can be inspected through status and graph commands.\n\n### Checking Status\n\nThe `flow plan status` command provides a view of a plan's jobs and their current states.\n\n-   **Default Tree View**: The default output shows a dependency tree with icons indicating the status of each job (e.g., `✓` Completed, `⚡` Running, `⏳` Pending, `✗` Failed).\n\n-   **Interactive TUI Mode**: The `-t` flag launches a terminal interface for the specified plan.\n    ```bash\n    flow plan status -t\n    ```\n    This UI allows for navigating the job graph, viewing job summaries, and executing actions like running, editing, or completing jobs directly from the interface.\n\n### Visualizing the Dependency Graph\n\nThe `flow plan graph` command generates a text-based representation of the job dependency chain. This is useful for understanding the workflow structure.\n\n\nSupported formats include `mermaid`, `dot`, and `ascii`.",
          "code_blocks": [
            "# Generate a Mermaid-syntax graph\nflow plan graph my-complex-plan\n\n# Generate an ASCII graph\nflow plan graph my-complex-plan --format ascii"
          ]
        },
        {
          "title": "Interaction with Development Environment",
          "content": "Grove Flow uses `tmux` to manage development environments for plans that are associated with a Git worktree.\n\n-   **`flow plan open [directory]`**: This command is the primary entrypoint into a plan's development environment. It finds the plan's configured worktree, creates or attaches to a `tmux` session for that worktree, and opens the plan's interactive status TUI (`flow plan status -t`).\n\n-   **`flow plan run \u003cjob-file\u003e`**: Running a job of type `interactive_agent` will launch the agent in a dedicated `tmux` window within the plan's session. This provides an isolated environment for tasks that may require user interaction."
        },
        {
          "title": "Plan Cleanup and Completion",
          "content": "The `flow plan finish` command initiates a guided workflow to clean up resources associated with a completed plan.\n\n\nThis command launches a terminal interface with a checklist of cleanup actions, which may include:\n-   Marking the plan as `finished` in its `.grove-plan.yml` file.\n-   Pruning the Git worktree directory from `.grove-worktrees/`.\n-   Deleting the local and remote Git branches associated with the worktree.\n-   Closing any associated `tmux` sessions.\n-   Moving the plan directory to an `.archive/` subdirectory to remove it from the default list view.",
          "code_blocks": [
            "flow plan finish user-profile-api"
          ]
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "Grove Flow is a command-line tool that executes multi-step workflows defined in Markdown files. It is intended for formalizing development workflows that involve code generation or analysis by LLMs, using Git worktrees for filesystem isolation.\n\n\u003c!-- placeholder for animated gif --\u003e",
      "subsections": [
        {
          "title": "Key Features",
          "content": "*   **Job Orchestration**: Executes a sequence of jobs defined in Markdown files. The execution order is determined by dependencies specified in each file's YAML frontmatter. It supports `shell`, `oneshot`, and `agent` job types.\n\n*   **Plan Management**: A \"Plan\" is a directory of Markdown job files representing a task. The `flow plan` command provides subcommands to `init`, `add`, `run`, `status`, `graph`, and `finish` these plans. A terminal interface (`flow plan status -t`) is available for monitoring plan progress.\n\n*   **Chat Integration**: The `flow chat` command manages conversational logs with an LLM, stored as a single Markdown file. The `flow plan extract` command can then be used to convert sections of the conversation into executable jobs within a plan.\n\n*   **Recipes and Templates**: The `flow plan init --recipe` command creates a new plan from a predefined directory structure of job files. The `flow plan add --template` command creates a new job from a single template file."
        },
        {
          "title": "How It Works",
          "content": "A \"Plan\" is a directory containing numbered Markdown files, where each file represents a \"Job\". Each job file contains YAML frontmatter that defines its `type` (`agent`, `oneshot`, `shell`), `status` (`pending`, `completed`), and dependencies via a `depends_on` key.\n\nThe orchestrator reads all job files in a plan directory, builds a dependency graph, and executes jobs whose dependencies have a `completed` status. Jobs of type `agent` or `interactive_agent` are executed within a Git worktree specified in the job's frontmatter, providing filesystem isolation."
        },
        {
          "title": "Ecosystem Integration",
          "content": "Grove Flow functions as a component of the Grove tool suite and executes other tools in the ecosystem as subprocesses.\n\n*   **Grove Context (`cx`)**: Before executing a job, `grove-flow` can call `grove-context` to read `.grove/rules` files and generate a file-based context. This context is then provided to the LLM.\n\n*   **Agent Tools (`claude`, `codex`)**: For `agent` or `interactive_agent` jobs, `flow` launches interactive agent tools as subprocesses within a dedicated tmux session, inheriting the specified worktree and context.\n\n*   **Grove Hooks (`grove-hooks`)**: The tool is designed to emit events for job lifecycle stages (e.g., job start, completion). These events can be tracked by `grove-hooks` for monitoring and logging purposes."
        },
        {
          "title": "Installation",
          "content": "Install via the Grove meta-CLI:\n\nVerify installation:\n\nRequires the `grove` meta-CLI. See the [Grove Installation Guide](https://github.com/mattsolo1/grove-meta/blob/main/docs/02-installation.md) if you don't have it installed.",
          "code_blocks": [
            "grove install flow",
            "flow version"
          ]
        }
      ]
    },
    "recipes-and-templates": {
      "title": "Recipes and Templates",
      "content": "Grove Flow includes features for creating reusable jobs and plans. Job templates define individual jobs, while plan recipes define multi-job workflows.",
      "subsections": [
        {
          "title": "Job Templates",
          "content": "A job template is a Markdown file containing frontmatter and a prompt body. It functions as a definition for creating new, individual jobs within a plan.\n\n### Using a Job Template\n\nThe `flow plan add` command creates a new job from a template using the `--template` flag.\n\n\nCommand-line flags such as `--prompt` or `--source-files` append additional content or context to the job being created from the template.\n\n### Listing Available Templates\n\nThe `flow plan templates list` command displays all available job templates. It searches for templates in the following order of precedence:\n\n1.  Project-specific (`.grove/job-templates/`)\n2.  User-global (`~/.config/grove/job-templates/`)\n3.  Built-in\n\n\n\n### Creating Custom Job Templates\n\nJob templates are Markdown files located in specific directories. Templates in a project's `.grove/job-templates/` directory override user-global templates with the same name.\n\n1.  **Project-specific**: `.grove/job-templates/`\n2.  **User-global**: `~/.config/grove/job-templates/`\n\nThe frontmatter of the template file defines default settings for the job, and the body serves as the base prompt.\n\n**Example: `.grove/job-templates/test-strategy.md`**\n\n\n### Built-in Job Templates\n\nGrove Flow includes the following built-in templates.\n\n| Template Name            | Description                                        |\n| ------------------------ | -------------------------------------------------- |\n| `agent-run`              | Generates a plan for an LLM agent to execute.      |\n| `agent-xml`              | Generates a detailed XML plan for an LLM agent.    |\n| `api-design`             | Designs a RESTful or GraphQL API.                  |\n| `architecture-overview`  | Generates an architecture overview of a codebase.  |\n| `chat`                   | A template for conversational chat jobs.           |\n| `code-review`            | Performs a code review.                            |\n| `deployment-runbook`     | Creates a production deployment runbook.           |\n| `documentation`          | Updates project documentation.                     |\n| `generate-plan`          | Generates a multi-step plan from a specification.  |\n| `incident-postmortem`    | Analyzes an incident and creates action items.     |\n| `learning-guide`         | Creates a learning guide for a codebase.           |\n| `learning-lang`          | Creates a language learning guide from code.       |\n| `migration-plan`         | Plans a technology or database migration.          |\n| `performance-analysis`   | Analyzes and suggests optimizations for performance.|\n| `refactoring-plan`       | Plans a large-scale refactoring effort.            |\n| `refine-plan-generic`    | A generic template for refining a plan.            |\n| `security-audit`         | Conducts a security audit of a codebase.           |\n| `tech-debt-assessment`   | Assesses and prioritizes technical debt.           |\n| `test-strategy`          | Creates a test strategy.                           |",
          "code_blocks": [
            "# Add a new job using the 'code-review' template\nflow plan add --title \"Review API Endpoints\" --template code-review",
            "flow plan templates list",
            "NAME                   SOURCE     DESCRIPTION\nagent-run              [Built-in] Generates a plan an LLM agent carries out\napi-design             [Built-in] Design a RESTful or GraphQL API\n...\nmy-custom-template     [User]     A custom template for team-specific tasks",
            "---\ndescription: \"Create a test strategy\"\ntype: \"oneshot\"\nmodel: \"gemini-2.5-pro\"\n---\n\nDevelop a testing strategy for this feature. Analyze existing test patterns and consider the balance between unit, integration, and e2e tests."
          ]
        },
        {
          "title": "Plan Recipes",
          "content": "A plan recipe is a directory containing a set of job files that define a multi-job workflow. Recipes are used to create new plans with a predefined structure.\n\n### Using a Plan Recipe\n\nThe `flow plan init --recipe` command creates a new plan directory and populates it with copies of the job files from the specified recipe.\n\n\nThis command creates the `plans/new-auth-feature` directory and adds the jobs defined in the `standard-feature` recipe, such as `01-spec.md` and `02-implement.md`.\n\n### Built-in Recipes\n\nGrove Flow provides several built-in recipes:\n\n-   **`standard-feature`**: A workflow for feature development: Spec -\u003e Implement -\u003e Git Status Checks -\u003e Review.\n-   **`chat-workflow`**: A workflow that starts with a `chat` job for exploration, followed by implementation and review.\n-   **`chat`**: A minimal plan containing only a single `chat` job. This is the default recipe for `flow plan init`.\n-   **`docgen-customize`**: A workflow for generating documentation: first a `chat` job to define the structure, then an `agent` job to write the content.\n\n### Creating Custom Recipes\n\nUser-defined recipes are directories located in `~/.config/grove/recipes/`. Each subdirectory within this location is treated as a recipe, and its `.md` job files are used to compose the new plan.\n\n**Example Directory Structure:**\n\n\nThis structure enables the command `flow plan init my-project-release --recipe my-release-workflow`.",
          "code_blocks": [
            "# Initialize a plan using the standard-feature recipe\nflow plan init new-auth-feature --recipe standard-feature",
            "~/.config/grove/recipes/\n└── my-release-workflow/\n    ├── 01-update-changelog.md\n    ├── 02-run-tests.md\n    └── 03-tag-release.md"
          ]
        },
        {
          "title": "Templating in Recipes",
          "content": "Recipe files can contain template variables using Go's `text/template` syntax.\n\n### Standard Variables\n\n-   `{{ .PlanName }}`: This variable is replaced with the name of the plan provided in the `flow plan init` command.\n\n**Example: `01-spec.md` from the `standard-feature` recipe**\n\n\nWhen running `flow plan init new-login-flow --recipe standard-feature`, the `{{ .PlanName }}` variable is replaced with `new-login-flow`.\n\n### Custom Variables\n\nThe `--recipe-vars` flag is used to pass key-value pairs to a recipe. These variables are accessible in templates via the `{{ .Vars.\u003ckey\u003e }}` syntax.\n\n-   **Passing Variables**:\n    -   Multiple flags: `--recipe-vars key1=val1 --recipe-vars key2=val2`\n    -   Comma-delimited: `--recipe-vars \"key1=val1,key2=val2\"`\n\n**Example: A recipe job `01-chat.md` that uses a custom `model` variable:**\n\n\n**Command to pass the variable:**\n\n\nDefault variables for a recipe can be defined in `grove.yml`. Variables passed via the CLI override those set in `grove.yml`.\n\n**Example: `grove.yml` with default recipe variables**",
          "code_blocks": [
            "---\nid: spec\ntitle: \"Specification for {{ .PlanName }}\"\nstatus: pending\ntype: oneshot\n---\n\nDefine the specification for the \"{{ .PlanName }}\" feature.",
            "---\ntitle: \"Chat about {{ .PlanName }}\"\ntype: chat\n{{ if .Vars.model }}model: \"{{ .Vars.model }}\"{{ end }}\n---\n\nLet's discuss the plan.",
            "flow plan init my-plan --recipe my-chat-recipe --recipe-vars model=gemini-2.5-pro",
            "flow:\n  recipes:\n    docgen-customize:\n      vars:\n        model: \"gemini-2.5-pro\"\n        rules_file: \"docs/docs.rules\""
          ]
        },
        {
          "title": "Dynamic Recipe Loading",
          "content": "Recipes can be loaded by executing an external command. The command is configured via the `get_recipe_cmd` key under the `recipes` section in `grove.yml`.\n\n\nThe specified command must output a JSON object to standard output. Each key in the object is a recipe name. The value is an object containing a `description` string and a `jobs` map, where keys are filenames and values are the file contents.\n\n**Example JSON Output:**\n\n\nWhen a recipe name exists in multiple sources, the order of precedence is: **User** \u003e **Dynamic** \u003e **Built-in**.",
          "code_blocks": [
            "# grove.yml\nflow:\n  recipes:\n    get_recipe_cmd: \"my-cli-tool recipes --json\"",
            "{\n  \"company-microservice\": {\n    \"description\": \"Standard microservice template.\",\n    \"jobs\": {\n      \"01-setup.md\": \"---\\ntitle: Setup {{ .PlanName }}\\n---\\nSetup the service.\",\n      \"02-deploy.md\": \"---\\ntitle: Deploy {{ .PlanName }}\\n---\\nDeploy the service.\"\n    }\n  }\n}"
          ]
        }
      ]
    },
    "working-with-jobs": {
      "title": "Working with Jobs",
      "content": "Jobs are the fundamental units of work in a Grove Flow plan. Each job is a single, executable step defined in a Markdown file with YAML frontmatter. This document covers how to create, configure, and manage these jobs.",
      "subsections": [
        {
          "title": "Creating Jobs",
          "content": "The primary command for adding a new job to a plan is `flow plan add`. It can be used interactively through a Terminal User Interface (TUI) or non-interactively with flags.\n\n### Interactive Mode (TUI)\n\nRunning `flow plan add` or `flow plan add -i` launches a terminal interface to guide the creation of a new job. This interface provides prompts and lists available options like job types and dependencies from the current plan.\n\n\n### Flag-Based Mode\n\nFor scripting or direct creation, job details can be provided using flags.\n\n**Example:**\n\nThis creates a new Markdown file (e.g., `02-implement-api-endpoints.md`) in the active plan directory with the specified frontmatter and prompt body.\n\n**Key `plan add` Flags:**\n\n| Flag | Alias | Description |\n| --- | --- | --- |\n| `--title` | | The title of the job. |\n| `--type` | `-t` | The job type (e.g., `agent`, `oneshot`, `shell`). |\n| `--depends-on` | `-d` | A job filename this new job depends on. Can be used multiple times. |\n| `--prompt` | `-p` | The main prompt or command for the job, provided inline. |\n| `--prompt-file` | `-f` | Path to a file containing the prompt content. |\n| `--source-files` | | Comma-separated list of files to include as context. |\n| `--template` | | The name of a job template to use. |\n| `--worktree` | | The git worktree for the job to run in. |\n| `--agent-continue` | | For `agent` jobs, continue the previous agent session in the same worktree. |\n| `--interactive` | `-i` | Force the interactive TUI mode. |\n\n### Writing Effective Prompts\n\n-   **State the Goal and Constraints**: Provide specific file paths, function names, and expected outcomes.\n-   **Provide Context**: Use `--source-files` or define dependencies on previous jobs to supply the LLM with necessary information.\n-   **Structure for the Job Type**: An `agent` prompt should be a high-level task description. A `oneshot` prompt can be a more specific question or instruction. A `shell` prompt is the command to be executed.",
          "code_blocks": [
            "# Add a job to the active plan\nflow plan add\n\n# Specify the plan directory and launch the TUI\nflow plan add ./plans/my-feature -i",
            "# Set 'my-feature' as the active plan\nflow plan set my-feature\n\n# Add an agent job that depends on a preceding job file\nflow plan add \\\n  --title \"Implement API Endpoints\" \\\n  --type \"agent\" \\\n  --depends-on \"01-spec.md\" \\\n  --prompt \"Implement the user API endpoints as defined in the spec.\""
          ]
        },
        {
          "title": "Job Types Explained",
          "content": "Grove Flow supports several job types, each executed by a specific mechanism.\n\n| Type | Description | Use Case |\n| --- | --- | --- |\n| `agent` | An alias for `interactive_agent`. | Implementing features, large-scale refactoring, debugging. |\n| `interactive_agent` | An agent session in `tmux` that allows for human interaction. | The primary type for complex, multi-step coding tasks. |\n| `headless_agent` | A non-interactive agent that runs in the background. | Fully automated code generation tasks, often in CI environments. |\n| `oneshot` | A single-shot LLM prompt for analysis, review, or generation. | Code reviews, generating documentation, or creating test plans. |\n| `shell` | Executes a shell command in the job's worktree or main repo. | Running tests, linting, building code, or file management. |\n| `chat` | A multi-turn conversational job for ideation and refinement. | Brainstorming a feature or breaking down a task before creating a formal plan. |\n| `generate-recipe` | Generates a reusable plan recipe from an existing plan. | Automating the creation of standardized development workflows. |"
        },
        {
          "title": "Dependencies Between Jobs",
          "content": "Workflows are created by defining dependencies between jobs. A job will not run until all of its dependencies have a status of `completed`. Dependencies are defined using the `depends_on` key in a job's frontmatter, which contains a list of the filenames of the jobs it depends on.\n\n**Example Frontmatter:**\n\nWhen using the CLI, dependencies are specified with the `-d` or `--depends-on` flag:",
          "code_blocks": [
            "---\nid: job-c5b1a2d3\ntitle: \"Review Code\"\nstatus: pending\ntype: oneshot\ndepends_on:\n  - 01-implement-feature.md\n  - 02-run-tests.md\n---",
            "flow plan add --title \"Review Code\" -d 01-implement-feature.md -d 02-run-tests.md"
          ]
        },
        {
          "title": "Models and LLM Configuration",
          "content": "The LLM used for a job is determined by a three-level hierarchy:\n\n1.  **Job Level**: The `model` key in a job's frontmatter (`.md` file). This has the highest precedence.\n2.  **Plan Level**: The `model` key in the plan's `.grove-plan.yml` file. This sets the default for all jobs in that plan and can be managed with `flow plan config set model \u003cmodel-id\u003e`.\n3.  **Project Level**: The `oneshot_model` key in your project's `grove.yml` file. This serves as the global default.\n\nUse the `flow models` command to see a list of recommended models."
        },
        {
          "title": "Job Templates",
          "content": "Templates allow for the reuse of common job structures and prompts.\n\n-   **List Templates**: To see all available templates (project-local, user-global, and built-in), run:\n    ```bash\n    flow plan templates list\n    ```\n\n-   **Use a Template**: Apply a template when adding a job using the `--template` flag.\n    ```bash\n    flow plan add --title \"Review API\" --template code-review\n    ```\n    This creates a new job using the pre-defined prompt and configuration from the `code-review` template. Additional instructions can be provided via the `--prompt` or `--prompt-file` flags, which will be appended to the template's prompt.\n\n-   **Creating Custom Templates**: Custom templates can be created by adding `.md` files to a `.grove/job-templates` directory in your project root or user config directory (`~/.config/grove/job-templates`)."
        },
        {
          "title": "Job Management",
          "content": "-   **Manual Completion**: For jobs that require manual intervention or verification (like `interactive_agent` or `chat`), mark them as complete with:\n    ```bash\n    flow plan complete \u003cjob-file\u003e\n    ```\n    When an `interactive_agent` job is completed, its session transcript is found via `grove aglogs` and appended to the job file.\n\n-   **Renaming Jobs**: To rename a job and automatically update all references to it in other jobs within the plan, use:\n    ```bash\n    flow plan jobs rename \u003cold-job-file\u003e \"New Job Title\"\n    ```\n\n-   **Updating Dependencies**: To replace a job's entire dependency list, use:\n    ```bash\n    flow plan jobs update-deps \u003cjob-file\u003e [new-dep-1.md] [new-dep-2.md]\n    ```\n    Running the command without any dependency files will clear all dependencies for the specified job.\n\n-   **Automatic Summarization**: If `summarize_on_complete: true` is set in `grove.yml`, a one-sentence summary of the job's accomplishment will be generated and added to the `summary` field in the job's frontmatter upon completion.\n\n-   **Job Output**: The output from `oneshot` and `shell` jobs is appended to the job's Markdown file under an `## Output` heading.\n\n-   **Debugging**: If a job fails, its status is set to `failed`. The output and logs within the job file can be used to debug the issue. Once fixed, the job can be re-run with `flow plan run \u003cjob-file\u003e`."
        },
        {
          "title": "Advanced Topics",
          "content": "-   **Job Frontmatter**: The YAML frontmatter in each job file is the source of truth for its configuration. These files can be edited directly to modify any aspect of a job.\n-   **Worktree Integration**: For `agent` and `shell` jobs, a `worktree` can be specified in the frontmatter. The job will then execute within that git worktree, providing isolation from the main branch."
        }
      ]
    }
  }
}