{
  "sections": {
    "chats": {
      "title": "Chats",
      "content": "Grove Flow includes `flow chat` commands for managing conversational workflows with LLMs. This provides an environment for exploration and problem-solving before creating a structured, multi-step plan.",
      "subsections": [
        {
          "title": "The Chat Workflow",
          "content": "Chats are distinct from plans. Plans are structured for sequential execution of discrete jobs, while chats are designed for interactive, back-and-forth conversation.\n\n| Feature         | `flow plan`                                      | `flow chat`                                        |\n| --------------- | ------------------------------------------------ | -------------------------------------------------- |\n| **Purpose**     | Structured execution, automation                 | Exploration, ideation, refinement, problem-solving |\n| **Structure**   | A directory of interdependent job files (a DAG)  | A single Markdown file capturing a linear conversation |\n| **Execution**   | Orchestrator runs jobs based on dependencies     | User and LLM respond sequentially in the same file   |\n\nA common workflow is to start with a `chat` to explore a concept, then use `flow plan extract` to convert parts of the conversation into an executable `plan`."
        },
        {
          "title": "Starting and Managing Chats",
          "content": "Conversations are managed as Markdown files in the directory specified by `flow.chat_directory` in your `grove.yml` configuration.\n\n### Initializing a Chat\n\nAny Markdown file can be turned into a chat job by initializing it, which adds YAML frontmatter to the file.\n\n\nThis command adds frontmatter to `chats/new-api-idea.md`:\n\n\n### Continuing a Conversation\n\nTo have the LLM respond to your latest message, use `flow chat run`. This command scans the chat directory for any files where the last turn was from a \"user\" and generates the next LLM response.\n\n\nAfter running, the file is updated with the LLM's response.\n\n### Listing Chats\n\nTo see all available chats and their current status, use `flow chat list`.\n\n\n**Example Output:**",
          "code_blocks": [
            "# Create a markdown file for an idea\ntouch chats/new-api-idea.md\n\n# Initialize it as a chat job\nflow chat -s chats/new-api-idea.md",
            "---\nid: job-a1b2c3d4\ntitle: new-api-idea\ntype: chat\nmodel: gemini-2.5-pro # Inherited from config\nstatus: pending_user\nupdated_at: \"2025-09-26T10:00:00Z\"\naliases: []\ntags: []\n---\n\n# My API Idea\n\nLet's design an API for user profiles.",
            "# Run all chats that are waiting for an LLM response\nflow chat run\n\n# Run a specific chat by its title\nflow chat run new-api-idea",
            "flow chat list",
            "TITLE             STATUS        MODEL             FILE\nnew-api-idea      pending_user  gemini-2.5-pro    new-api-idea.md\nold-feature       completed     gemini-2.0-flash  old-feature.md"
          ]
        },
        {
          "title": "Context in Chat Sessions",
          "content": "When `flow chat run` is executed, it uses `grove-context` to gather file context based on rules defined in your project's `.grove/rules` file. This context is included in the request to the LLM."
        },
        {
          "title": "From Conversation to Execution",
          "content": "`chat` jobs are for conversation; their output is text. To execute code or run commands, content from a chat must be extracted into a `plan` containing an `agent` or `shell` job. An `interactive_agent` job created from a chat can then be launched into a `tmux` session with `flow plan launch`."
        },
        {
          "title": "Extracting Jobs from Chats",
          "content": "The `flow plan extract` command converts parts of a conversation into executable jobs within a plan.\n\n### Listing Extractable Blocks\n\nEach LLM response in a chat file is tagged with a unique ID inside a `\u003c!-- grove: ... --\u003e` comment. You can list all extractable blocks within a file.\n\n\n**Example Output:**\n\n\n### Creating a Job from a Block\n\nUsing a block ID, you can create a new job in a plan directory.\n\n\nThis creates a new job in the `api-implementation` plan containing the database schema design from the chat, ready to be implemented by an agent.\n\nYou can also extract the entire body of a chat file using the `all` keyword:",
          "code_blocks": [
            "flow plan extract list --file chats/new-api-idea.md",
            "Found 2 extractable blocks in chats/new-api-idea.md:\n\nID: a1b2c3d4\nType: llm\nLine: 10\nPreview: Here is a proposed API structure...\n---\nID: e5f6g7h8\nType: llm\nLine: 45\nPreview: The database schema could look like this...\n---",
            "# First, ensure a plan exists\nflow plan init api-implementation --worktree\n\n# Extract a block into the new plan\nflow plan extract e5f6g7h8 --file ./chats/new-api-idea.md --title \"Implement API Schema\"",
            "flow plan extract all --file chats/new-api-idea.md --title \"Full API Discussion\""
          ]
        },
        {
          "title": "Chat Configuration",
          "content": "Chat behavior is configured in your project's `grove.yml` file under the `flow` key.\n\n\nYou can override the model for a specific chat by setting the `model` key in the chat file's frontmatter.",
          "code_blocks": [
            "# .grove/config.yml or grove.yml\nflow:\n  # Directory where chat markdown files are stored\n  chat_directory: ./chats\n  \n  # Default model for oneshot and chat jobs\n  oneshot_model: gemini-2.5-pro"
          ]
        },
        {
          "title": "Use Cases and Examples",
          "content": "Chats are suitable for exploratory and iterative scenarios.\n\n*   **Brainstorming**: Explore different approaches to a new feature.\n*   **Problem Exploration**: Work through a bug with an LLM, providing logs and code snippets.\n*   **Prototyping**: Ask an LLM to generate boilerplate code or a proof-of-concept.\n*   **Documentation**: Draft an outline for new documentation.\n\n### Example Workflow: From Idea to Plan\n\n1.  **Start a chat:**\n    ```bash\n    echo \"# Idea: Refactor auth service\" \u003e chats/auth-refactor.md\n    flow chat -s chats/auth-refactor.md\n    ```\n\n2.  **Add your initial prompt to the file and run the chat:**\n    ```bash\n    # (Edit chats/auth-refactor.md to add details)\n    flow chat run auth-refactor\n    ```\n\n3.  **After a few turns, you have a solid plan from the LLM. List the blocks:**\n    ```bash\n    flow plan extract list --file chats/auth-refactor.md\n    # Output shows block ID: a1b2c3\n    ```\n\n4.  **Create a new plan and extract the final LLM response into it:**\n    ```bash\n    flow plan init refactor-auth-service --worktree\n    flow plan extract a1b2c3 --file ./chats/auth-refactor.md --title \"Refactor Authentication\"\n    ```\n\n5.  **Run the new, structured plan:**\n    ```bash\n    flow plan run\n    ```"
        }
      ]
    },
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a reference for the `flow` command-line interface, covering all subcommands and their options.",
      "subsections": [
        {
          "title": "`flow plan`",
          "content": "Manages multi-step orchestration plans.\n\n### `flow plan init`\n\nInitializes a new plan directory.\n\n**Syntax**\n\n\n**Description**\n\nCreates a new plan in the specified directory, including a `.grove-plan.yml` file for default configuration. Running the command without a directory name or with the `-t` flag launches an interactive terminal interface to guide plan creation.\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--extract-all-from` | | Path to a markdown file to extract all content into an initial job. | |\n| `--force` | `-f` | Overwrite the destination directory if it already exists. | `false` |\n| `--model` | | Default model for jobs in this plan (e.g., `gemini-2.5-pro`). | (none) |\n| `--open-session` | | Immediately open a tmux session for the plan's worktree. | `false` |\n| `--recipe` | | Initialize the plan from a pre-defined recipe template. | `chat-workflow` |\n| `--recipe-vars` | | Variables for recipe templates (`key=value`). Can be used multiple times. | (none) |\n| `--target-agent-container` | | Default container for agent jobs in the plan. | (none) |\n| `--tui` | `-t` | Launch an interactive TUI to create a new plan. | `false` |\n| `--worktree` | | Set a default worktree. If no name is provided, uses the plan directory name. | (none) |\n\n**Examples**\n\n\n### `flow plan add`\n\nAdds a new job to a plan.\n\n**Syntax**\n\n\n**Description**\n\nAdds a new job file to a plan directory. If no directory is specified, it uses the active plan. The command can be run interactively or non-interactively with flags.\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--agent-continue` | | Continue the last agent session (adds `--continue` flag to the agent command). | `false` |\n| `--depends-on` | `-d` | List of job filenames this job depends on. | (none) |\n| `--interactive` | `-i` | Launch an interactive TUI to create the new job. | `false` |\n| `--output-type` | | Output type: `file`, `commit`, `none`, or `generate_jobs`. | `file` |\n| `--prompt` | `-p` | Inline prompt text for the job. | (from stdin) |\n| `--prompt-file` | `-f` | Path to a file containing the prompt. | (none) |\n| `--source-files` | | Comma-separated list of source files for context. | (none) |\n| `--template` | | Name of a job template to use. | (none) |\n| `--title` | | Title of the job. | (required) |\n| `--type` | `-t` | Job type: `agent`, `interactive_agent`, `headless_agent`, `oneshot`, `shell`, `chat`. | `agent` |\n| `--worktree` | | Explicitly set the worktree for this job. | (plan default) |\n\n**Examples**\n\n\n### `flow plan list`\n\nLists all plans in the configured directory.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--include-finished` | | Include plans marked as \"finished\". | `false` |\n| `--verbose` | `-v` | Show detailed information for each plan. | `false` |\n\n### `flow plan tui`\n\nLaunches an interactive terminal interface for browsing and managing plans.\n\n**Syntax**\n\n\n### `flow plan set`, `current`, `unset`\n\nManage the active plan for the current context.\n\n**Syntax**\n\n\n### `flow plan status`\n\nShows the status of all jobs in a plan.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--format`| `-f` | Output format: `tree`, `list`, `json`. | `tree` |\n| `--graph` | `-g` | Show a dependency graph in Mermaid syntax. | `false` |\n| `--tui` | `-t` | Launch an interactive terminal interface status view. | `false` |\n| `--verbose`| `-v` | Show detailed job information. | `false` |\n\n### `flow plan graph`\n\nVisualizes the job dependency graph.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--format` | `-f` | Output format: `mermaid`, `dot`, `ascii`. | `mermaid` |\n| `--output` | `-o` | Output file path (defaults to stdout). | (stdout) |\n| `--port` | `-p` | Port for the web server when using `--serve`. | `8080` |\n| `--serve` | `-s` | Serve an interactive HTML visualization. | `false` |\n\n### `flow plan run`\n\nRuns jobs in a plan.\n\n**Syntax**\n\n\n**Description**\n\nExecutes jobs in an orchestration plan. Without arguments, it runs the next available jobs based on dependencies.\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--all` | `-a` | Run all pending jobs in the plan sequentially. | `false` |\n| `--model` | | Override the LLM model for this run. | (none) |\n| `--next` | `-n` | Run the next available jobs. (This is the default) | `false` |\n| `--parallel` | `-p` | Maximum number of jobs to run in parallel. | `3` |\n| `--skip-interactive` | | Skip any interactive agent jobs. | `false` |\n| `--watch` | `-w` | Watch plan progress in real-time. | `false` |\n| `--yes` | `-y` | Skip all confirmation prompts. | `false` |\n\n### `flow plan complete`\n\nMarks a job as completed.\n\n**Syntax**\n\n\n**Description**\n\nManually marks a job's status as `completed`. This is useful for interactive jobs or when an external process has finished a task.\n\n### `flow plan open`\n\nOpens a plan's worktree in a dedicated tmux session.\n\n**Syntax**\n\n\n### `flow plan launch`\n\nLaunches an interactive agent job in a tmux session.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--host` | | Launch the agent on the host machine instead of in a container. | `false` |\n\n### `flow plan finish`\n\nGuides through the process of finishing and cleaning up a plan.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--archive` | | Archive the plan directory using `nb archive`. | `false` |\n| `--clean-dev-links` | | Clean up development binary links from the worktree. | `false` |\n| `--close-session` | | Close the associated tmux session. | `false` |\n| `--delete-branch` | | Delete the local git branch. | `false` |\n| `--delete-remote` | | Delete the remote git branch. | `false` |\n| `--force` | | Force git operations (e.g., deleting unmerged branches). | `false` |\n| `--prune-worktree` | | Remove the git worktree directory. | `false` |\n| `--yes` | `-y` | Automatically confirm all cleanup actions. | `false` |\n\n### `flow plan config`\n\nGets or sets configuration values in a plan's `.grove-plan.yml`.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Description |\n| :--- | :--- |\n| `--get` | Get a specific configuration value by key. |\n| `--set` | Set a configuration value (e.g., `key=value`). |\n| `--json` | Output the configuration in JSON format. |\n\n### `flow plan extract`\n\nExtracts content from a chat or markdown file into a new job.\n\n**Syntax**\n\n\n**Description**\n\n`list`: Lists all extractable block IDs in the source file.\n`all`: Extracts all content below the frontmatter into a single new job.\n`\u003cblock-id...\u003e`: Extracts one or more specific blocks into a new job.\n\n**Flags**\n\n| Flag | Shorthand | Description |\n| :--- | :--- | :--- |\n| `--depends-on` | `-d` | Dependencies for the new job. |\n| `--file` | | Source markdown file to extract from. |\n| `--model` | | LLM model for the new job. |\n| `--output` | | Output type for the new job. |\n| `--title` | | Title for the new job (required). |\n| `--worktree` | | Worktree for the new job. |\n| `--json` | | Output block list in JSON format (for `list` command). |\n\n### `flow plan templates list`\n\nLists available job templates.\n\n**Syntax**\n\n\n### `flow plan jobs list`\n\nLists available job types.\n\n**Syntax**\n\n\n### `flow plan rebase`\n\nRebases branches for the plan's worktree(s).\n\n**Syntax**\n\n\n### `flow plan step`\n\nSteps through plan execution interactively.\n\n**Syntax**\n\n\n### `flow plan worktree`\n\nManages worktrees for all jobs in a plan.\n\n**Syntax**\n\n\n---",
          "code_blocks": [
            "flow plan init \u003cdirectory\u003e [flags]",
            "# Initialize a new plan in the 'new-feature' directory\nflow plan init new-feature\n\n# Initialize a plan with a git worktree named 'feature-branch'\nflow plan init new-feature --worktree=feature-branch\n\n# Initialize a plan from the 'standard-feature' recipe\nflow plan init user-auth --recipe standard-feature",
            "flow plan add [directory] [flags]",
            "# Add a new agent job to the active plan interactively\nflow plan add -i\n\n# Add a shell job to 'my-plan' that depends on a previous job\nflow plan add my-plan -t shell -p \"npm install\" -d \"01-setup.md\" --title \"Install Dependencies\"\n\n# Add a job using a template and source files for context\nflow plan add --template code-review --source-files src/main.go --title \"Review Main Logic\"",
            "flow plan list [flags]",
            "flow plan tui",
            "flow plan set \u003cplan-directory\u003e\nflow plan current\nflow plan unset",
            "flow plan status [directory] [flags]",
            "flow plan graph [directory] [flags]",
            "flow plan run [job-file] [flags]",
            "flow plan complete \u003cjob-file\u003e",
            "flow plan open [directory]",
            "flow plan launch \u003cjob-file\u003e [flags]",
            "flow plan finish [directory] [flags]",
            "flow plan config [directory] [flags]",
            "flow plan extract \u003cblock-id... | all | list\u003e --file \u003csource-file\u003e --title \u003cnew-job-title\u003e [flags]",
            "flow plan templates list",
            "flow plan jobs list",
            "flow plan rebase [target] [--yes | --abort | --continue]",
            "flow plan step [directory]",
            "flow plan worktree set \u003cplan-directory\u003e \u003cworktree-name\u003e\nflow plan worktree unset \u003cplan-directory\u003e"
          ]
        },
        {
          "title": "`flow chat`",
          "content": "Manages conversational, multi-turn AI interactions.\n\n**Syntax**\n\n\n**Description**\n\nThe `chat` subcommand is used for ideation and refinement. A markdown file can be turned into a `chat` job to have a conversation with an LLM. The results can later be extracted into a formal plan.\n\n---",
          "code_blocks": [
            "# Initialize a markdown file as a runnable chat\nflow chat -s \u003cfile.md\u003e [flags]\n\n# List all chats\nflow chat list [flags]\n\n# Run pending chats\nflow chat run [title...]"
          ]
        },
        {
          "title": "`flow models`",
          "content": "Lists available LLM models.\n\n**Syntax**\n\n\n**Description**\n\nDisplays a list of recommended LLM models that can be used in job and chat frontmatter.\n\n**Flags**\n\n| Flag | Description |\n| :--- | :--- |\n| `--json` | Output the list in JSON format. |\n\n---",
          "code_blocks": [
            "flow models [flags]"
          ]
        },
        {
          "title": "`flow starship`",
          "content": "Manages Starship prompt integration.\n\n**Syntax**\n\n\n---",
          "code_blocks": [
            "flow starship install\nflow starship status"
          ]
        },
        {
          "title": "`flow version`",
          "content": "Prints version information for the `flow` binary.\n\n**Syntax**\n\n\n**Flags**\n\n| Flag | Description |\n| :--- | :--- |\n| `--json` | Output version info in JSON format. |\n\n---",
          "code_blocks": [
            "flow version [flags]"
          ]
        },
        {
          "title": "Global Options",
          "content": "| Flag | Description |\n| :--- | :--- |\n| `--config` | Path to a custom `grove.yml` configuration file. |\n| `--json` | Output command results in JSON format. |\n| `--verbose`| Enable verbose logging output. |\n| `--quiet` | Suppress all non-essential output. |\n| `--help` | Display help for any command. |\n\n---"
        },
        {
          "title": "Environment Variables",
          "content": "- `GROVE_ECOSYSTEM_ROOT`: Specifies the root directory of the Grove ecosystem repositories, used to locate shared resources.\n- `GROVE_FLOW_SKIP_DOCKER_CHECK`: If set to `true`, skips pre-flight checks for the Docker daemon (used in testing).\n- `GROVE_CONFIG`: Specifies a path to a custom `grove.yml` configuration file.\n\n---"
        },
        {
          "title": "Configuration Files",
          "content": "- **`grove.yml`**: The main project-level configuration file. `flow` settings are placed under the `flow:` key.\n- **`.grove-plan.yml`**: A plan-specific configuration file located inside a plan directory. Values here override the project-level `grove.yml`.\n- **`.grove/state.yml`**: A local file that stores the active plan for the current directory or worktree context. This file should not be committed to version control."
        }
      ]
    },
    "configuration": {
      "title": "Configuration",
      "content": "Grove Flow is configured through YAML files at both the project and plan level. This layered approach allows for setting defaults and managing workflows.",
      "subsections": [
        {
          "title": "Project-Level Configuration (`grove.yml`)",
          "content": "The primary configuration for Grove Flow resides under the `flow` key in your project's `grove.yml` file. This file sets global defaults for all plans within the repository.\n\n\n### Core Settings\n\n-   `plans_directory`: Specifies the directory where plan subdirectories are stored. It supports path variables like `${REPO}`. Defaults to `./plans`.\n-   `chat_directory`: Defines the location for standalone chat files managed by the `flow chat` command. Defaults to `./chats`.\n-   `oneshot_model`: Sets the default LLM model for `oneshot` and `chat` jobs.\n-   `target_agent_container`: Specifies the default Docker container image to use for `agent` and `interactive_agent` jobs.\n-   `summarize_on_complete`: A boolean (`true` or `false`) that enables or disables automatic job summarization when a job is marked as completed.\n-   `summary_model`: The LLM model to use for generating job summaries.\n-   `summary_prompt`: A custom prompt template for summarization. Must include a `%s` placeholder for the job content.\n-   `summary_max_chars`: The maximum character length for a generated summary.\n\n### Recipe Configuration\n\nUnder the `recipes` key, you can configure how plan recipes are handled:\n\n-   `get_recipe_cmd`: An optional command that, when executed, outputs a JSON definition of available recipes. This allows for dynamic loading of recipes from external sources.\n-   `vars`: A sub-key for defining default variables for a specific, named recipe. These variables are accessible within the recipe's templates and can be overridden at initialization time with the `--recipe-vars` flag.",
          "code_blocks": [
            "# ./.grove/config.yml or grove.yml\nflow:\n  # Directory where plans are stored. Supports variables like ${REPO}.\n  # Default: ./plans\n  plans_directory: ./plans\n  \n  # Directory for chat-based jobs.\n  # Default: ./chats\n  chat_directory: ./chats\n\n  # Default model for oneshot and chat jobs.\n  # No default, must be set here or at the plan/job level.\n  oneshot_model: gemini-2.5-pro\n  \n  # Default container image for agent jobs.\n  # No default, must be set.\n  target_agent_container: grove-agent-ide\n\n  # Configuration for job summarization on completion.\n  summarize_on_complete: true\n  summary_model: gemini-2.5-flash\n  summary_prompt: \"Provide a one-sentence summary of the outcome from the following job log, under 150 characters:\\n---\\n%s\"\n  summary_max_chars: 150\n\n  # Configuration for plan recipes.\n  recipes:\n    # (Optional) Command to execute for discovering dynamic recipes.\n    # The command should output a JSON object where keys are recipe names.\n    get_recipe_cmd: \"grove-recipes list --json\"\n    \n    # (Optional) Default variables for specific recipes.\n    # These can be overridden by the --recipe-vars flag.\n    docgen-customize:\n      vars:\n        model: \"gemini-2.5-pro\"\n        rules_file: \"docs/docs.rules\""
          ]
        },
        {
          "title": "Plan-Level Configuration (`.grove-plan.yml`)",
          "content": "A `.grove-plan.yml` file inside a plan's directory overrides project-level settings for that specific plan, making plans self-contained.\n\n\n### Plan-Specific Settings\n\n-   `model`: Overrides the default LLM model for all jobs within this plan.\n-   `worktree`: Sets a default `worktree` for `agent`, `interactive_agent`, and `shell` jobs in the plan. This is automatically set by `flow plan init --worktree`.\n-   `target_agent_container`: Overrides the default container for agent jobs in the plan.\n-   `status`: Can be set to `finished` to mark the plan as complete. Commands like `flow plan list` and `flow plan tui` will hide finished plans by default.\n-   `repos`: For \"ecosystem worktrees\" in projects with submodules, this key specifies which repositories to include when creating the worktree.",
          "code_blocks": [
            "# ./plans/my-feature-plan/.grove-plan.yml\n\n# Override the default model for all jobs in this plan.\nmodel: gemini-2.5-pro\n\n# Set a default worktree for all agent jobs in this plan.\nworktree: feature/my-new-api\n\n# For ecosystem worktrees, specify which repositories to include.\n# If omitted, all submodules are included.\nrepos:\n  - grove-core\n  - grove-flow\n\n# Can be used to filter finished plans from commands like `flow plan list`.\nstatus: finished"
          ]
        },
        {
          "title": "Managing Plan Configuration",
          "content": "The `flow plan config` command reads and writes values to a plan's `.grove-plan.yml` file.\n\n-   **View current configuration:**\n    ```bash\n    flow plan config my-feature-plan\n    ```\n-   **Get a specific value:**\n    ```bash\n    flow plan config my-feature-plan --get model\n    ```\n-   **Set one or more values:**\n    ```bash\n    flow plan config my-feature-plan --set model=gemini-2.5-pro --set worktree=feature/new\n    ```\n    This command also propagates new values to existing job files within the plan that do not already have that value explicitly set in their frontmatter."
        },
        {
          "title": "Configuration Inheritance",
          "content": "Grove Flow resolves settings in the following order of precedence (highest to lowest):\n\n1.  **Job Frontmatter**: Values in a job's markdown file (`.md`).\n2.  **Plan-Level (`.grove-plan.yml`)**: Values in the plan's configuration file.\n3.  **Project-Level (`grove.yml`)**: Global values in the project's configuration file.\n4.  **System Defaults**: Hardcoded fallbacks within the application."
        },
        {
          "title": "Environment Variables",
          "content": "-   `GROVE_CONFIG`: Specifies a path to a custom `grove.yml` file, overriding the default search behavior.\n-   `GROVE_ECOSYSTEM_ROOT`: A path to the root of a Grove ecosystem checkout, used to locate other Grove tools and shared resources.\n-   LLM provider API keys (e.g., `GEMINI_API_KEY`) are managed by their respective tools (`grove-gemini`, `grove-openai`) but are required for `grove-flow` to function."
        },
        {
          "title": "Best Practices",
          "content": "-   Set frequently used models and container images in the project `grove.yml` to reduce repetition.\n-   Define plan-specific models or worktrees in `.grove-plan.yml` to make plans self-contained.\n-   Store LLM API keys in your environment or a secure keychain, not in configuration files.\n-   Use `flow plan set` to make a plan active, which simplifies commands by removing the need to specify the plan directory repeatedly. This state is local to your checkout or worktree."
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "This document provides examples for using `grove-flow` for single- and multi-step development workflows.",
      "subsections": [
        {
          "title": "Example 1: Basic Plan Execution",
          "content": "This example covers the process of creating a plan, adding a single job, and running it.\n\n1.  **Initialize the Plan**\n\n    Create a new plan directory and an associated Git worktree. The `--worktree` flag creates a Git worktree and branch named after the plan (`new-feature-endpoint`), which isolates file changes.\n\n    ```bash\n    flow plan init new-feature-endpoint --worktree\n    ```\n\n    This command creates the `plans/new-feature-endpoint` directory, adds a `.grove-plan.yml` configuration file, and sets `new-feature-endpoint` as the active plan.\n\n2.  **Add an Agent Job**\n\n    Add a job to the active plan. The `agent` job type is for code generation tasks.\n\n    ```bash\n    flow plan add --title \"Implement User Endpoint\" --type agent \\\n      -p \"Create a new Go API endpoint at /api/v1/users for basic CRUD operations.\"\n    ```\n\n    This creates the file `plans/new-feature-endpoint/01-implement-user-endpoint.md` containing the job's configuration and prompt.\n\n3.  **Check the Status**\n\n    View the plan's status using the interactive terminal UI (`-t`).\n\n    ```bash\n    flow plan status -t\n    ```\n\n    The TUI displays the \"Implement User Endpoint\" job with a `pending` status.\n\n4.  **Run the Plan**\n\n    Execute the next available job in the plan.\n\n    ```bash\n    flow plan run\n    ```\n\n    `grove-flow` finds the pending job and executes it in the `new-feature-endpoint` worktree."
        },
        {
          "title": "Example 2: Multi-Job Feature Workflow",
          "content": "`grove-flow` orchestrates multi-step workflows with dependencies. This example shows a development pattern of specification, implementation, and testing.\n\n1.  **Initialize the Plan**\n\n    Create a plan for a new user authentication feature.\n\n    ```bash\n    flow plan init user-auth-feature --worktree\n    ```\n\n2.  **Add a Specification Job**\n\n    The first step is a `oneshot` job for an LLM to write a technical specification. This job has no dependencies.\n\n    ```bash\n    flow plan add --title \"Define Authentication Spec\" --type oneshot \\\n      -p \"Write a technical specification for a JWT-based authentication system, including data models and API endpoints.\"\n    ```\n\n    This creates `01-define-authentication-spec.md`.\n\n3.  **Add an Implementation Job**\n\n    Next, add an `agent` job to implement the feature. The `-d` flag specifies that this job depends on the completion of the specification job.\n\n    ```bash\n    flow plan add --title \"Implement Auth Logic\" --type agent \\\n      -d \"01-define-authentication-spec.md\" \\\n      -p \"Implement the authentication logic based on the specification from the previous step.\"\n    ```\n\n    This creates `02-implement-auth-logic.md`. `grove-flow` will not run this job until `01-define-authentication-spec.md` is complete.\n\n4.  **Add a Testing Job**\n\n    Add another `agent` job to write tests, which depends on the implementation.\n\n    ```bash\n    flow plan add --title \"Write Unit Tests\" --type agent \\\n      -d \"02-implement-auth-logic.md\" \\\n      -p \"Write unit and integration tests for the authentication system.\"\n    ```\n\n    This creates `03-write-unit-tests.md`.\n\n5.  **Run the Workflow**\n\n    Execute all jobs in the plan according to their dependency order.\n\n    ```bash\n    flow plan run --all\n    ```\n\n    `grove-flow` runs the specification job first. Once it completes, it runs the implementation job, followed by the testing job."
        },
        {
          "title": "Example 3: Chat-to-Plan Workflow",
          "content": "The `chat` and `extract` commands are used to convert an unstructured conversation into an executable plan.\n\n1.  **Start a Chat**\n\n    Create a Markdown file for an idea and initialize it as a chat job. This adds the required frontmatter to the file.\n\n    ```bash\n    # Create the directory for chat files\n    mkdir -p chats\n\n    # Create the file\n    echo \"# Idea: Refactor the logging system\" \u003e chats/logging-refactor.md\n\n    # Initialize it as a runnable chat job\n    flow chat -s chats/logging-refactor.md\n    ```\n\n2.  **Iterate with the LLM**\n\n    Run the chat to get a response from the LLM. Each LLM response is automatically assigned a unique block ID.\n\n    ```bash\n    # Get the first response from the LLM\n    flow chat run \"Idea: Refactor the logging system\"\n    ```\n\n    After several turns, `chats/logging-refactor.md` might contain:\n\n    ```markdown\n    ---\n    title: Idea: Refactor the logging system\n    type: chat\n    ---\n    # Idea: Refactor the logging system\n\n    \u003c!-- grove: {\"id\": \"a1b2c3\"} --\u003e\n    ## LLM Response\n    A high-level plan for the logging refactor:\n    1.  Introduce a structured logging library.\n    2.  Define standardized log levels.\n    3.  Create a centralized logging configuration.\n\n    \u003c!-- grove: {\"template\": \"chat\"} --\u003e\n    That sounds good. Can you create a more detailed technical plan for step 1?\n\n    \u003c!-- grove: {\"id\": \"d4e5f6\"} --\u003e\n    ## LLM Response\n    For step 1, we will:\n    - Add a logging library to `go.mod`.\n    - Create a new package `internal/logging`.\n    - Implement a `NewLogger()` function.\n    ```\n\n3.  **Extract a Job from the Chat**\n\n    The LLM's second response (ID `d4e5f6`) can be extracted into a formal plan.\n\n    ```bash\n    # First, create a new plan to hold the extracted job\n    flow plan init logging-refactor-plan --with-worktree\n\n    # Now, extract the block from the chat into the active plan\n    flow plan extract d4e5f6 --title \"Implement Structured Logger\" \\\n      --file chats/logging-refactor.md\n    ```\n\n    This command finds the content of block `d4e5f6` and creates a new job file (`01-implement-structured-logger.md`) in the `logging-refactor-plan`. This job is now part of a formal workflow and can be executed with `flow plan run`."
        }
      ]
    },
    "managing-plans": {
      "title": "Managing Plans",
      "content": "Grove Flow uses \"Plans\" to organize and execute multi-step workflows. A plan is a directory that contains job files, configuration, and related artifacts. This document covers the commands used to create, manage, inspect, and clean up plans.",
      "subsections": [
        {
          "title": "Plan Initialization",
          "content": "The `flow plan init` command creates a plan directory and a default configuration file, `.grove-plan.yml`.\n\n### Basic Initialization\n\nTo create a new plan, provide a directory name. The base name of the directory is used as the plan's identifier.\n\n\nThis command creates a directory at `./plans/new-feature-development` (if `plans_directory` is configured), creates a `.grove-plan.yml` file with default settings, and sets `new-feature-development` as the active plan.\n\n### Using Worktrees\n\nFor jobs that modify code, the `--worktree` flag is used to create an isolated Git worktree.\n\n**Auto-named Worktree:**\nUsing `--worktree` without a value creates a worktree and a branch with the same name as the plan.\n\n\n**Custom-named Worktree:**\nTo specify a different branch name for the worktree, provide a value to the flag.\n\n\n### Using Recipes\n\nRecipes are plan templates. The `--recipe` flag initializes a plan from a built-in or custom recipe, populating it with pre-defined jobs.\n\n\n### Extracting from Files\n\nA plan can be initialized from the content of an existing file using `--extract-all-from`. This creates an initial job containing the body of the source file.\n\n\n### Combined Initialization\n\nThe `init` flags can be combined. For example, a plan can be created from a recipe, have content extracted into its first job, and be configured with a worktree in a single command.",
          "code_blocks": [
            "flow plan init new-feature-development",
            "# Creates a worktree and branch named \"api-refactor\"\nflow plan init api-refactor --worktree",
            "# Creates a worktree and branch named \"feature/user-auth\"\nflow plan init user-authentication --worktree=feature/user-auth",
            "# Initializes a plan using the 'standard-feature' recipe\nflow plan init implement-caching --recipe standard-feature",
            "# Creates a plan with one job containing the content of notes.md\nflow plan init plan-from-notes --extract-all-from ./chats/notes.md",
            "flow plan init user-profile-api \\\n  --recipe standard-feature \\\n  --extract-all-from ./chats/api-discussion.md \\\n  --worktree"
          ]
        },
        {
          "title": "Listing and Browsing Plans",
          "content": "Plans can be listed from the command line or browsed in a terminal interface.\n\n-   **`flow plan list`**: Displays a table of all plans in the configured `plans_directory`, showing the number of jobs and a summary of their statuses.\n-   **`flow plan tui`**: Launches a terminal user interface for navigating plans. This interface allows viewing plan details, opening their status view, and managing their lifecycle."
        },
        {
          "title": "Active Plan Management",
          "content": "Grove Flow uses the concept of an \"active plan\" to determine the target for commands like `flow plan add` or `flow plan status` when a directory is not specified. The active plan is stored in a local `.grove/state.yml` file.\n\n-   **`flow plan set \u003cplan-directory\u003e`**: Sets the specified plan as active.\n    ```bash\n    flow plan set user-profile-api\n    ```\n-   **`flow plan current`**: Displays the name of the currently active plan.\n-   **`flow plan unset`**: Clears the active plan setting."
        },
        {
          "title": "Status and Visualization",
          "content": "The state of a plan and the relationships between its jobs can be inspected through status and graph commands.\n\n### Checking Status\n\nThe `flow plan status` command provides a view of a plan's jobs.\n\n-   **Default Tree View**: The default output shows a dependency tree with icons indicating the status of each job (`✓` Completed, `⚡` Running, `⏳` Pending, `✗` Failed).\n\n-   **Interactive TUI Mode**: For a more detailed view, use the `-t` flag.\n    ```bash\n    flow plan status -t\n    ```\n    This launches a terminal UI where you can navigate the job graph, view job summaries, and execute actions like running, editing, or completing jobs.\n\n### Visualizing the Dependency Graph\n\nThe `flow plan graph` command generates a visual representation of the workflow's dependency chain.\n\n\nSupported formats include `mermaid`, `dot`, and `ascii`.",
          "code_blocks": [
            "# Generate a Mermaid-syntax graph\nflow plan graph my-complex-plan\n\n# Generate an ASCII graph\nflow plan graph my-complex-plan --format ascii"
          ]
        },
        {
          "title": "Interaction with Development Environment",
          "content": "Grove Flow provides commands for interacting with a plan's development environment, primarily through `tmux`.\n\n-   **`flow plan open [directory]`**: This command finds a plan's configured worktree, creates or switches to a `tmux` session for it, and opens the interactive status TUI (`flow plan status -t`).\n\n-   **`flow plan launch \u003cjob-file\u003e`**: This command is used to start an `interactive_agent` job. It launches the agent in a dedicated `tmux` session for tasks that may require user interaction."
        },
        {
          "title": "Plan Cleanup and Completion",
          "content": "The `flow plan finish` command provides a guided workflow to clean up resources associated with a completed plan.\n\n\nThis command launches a terminal interface with a checklist of cleanup actions:\n-   Marking the plan as `finished` in its `.grove-plan.yml`.\n-   Pruning the Git worktree directory.\n-   Deleting the local and remote Git branches associated with the worktree.\n-   Closing any associated `tmux` sessions.\n-   Archiving the plan directory.",
          "code_blocks": [
            "flow plan finish user-profile-api"
          ]
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "\u003cimg src=\"./images/grove-flow-readme.svg\" width=\"60%\" /\u003e\n\nGrove Flow is a command-line tool that executes multi-step workflows defined in Markdown files. It uses Git worktrees to facilitate parallel development and is intended for formalizing development workflows that involve code generation or analysis by LLMs.\n\n\u003c!-- placeholder for animated gif --\u003e",
      "subsections": [
        {
          "title": "Key Features",
          "content": "*   **Job Orchestration**: Executes a sequence of jobs defined in Markdown files. The execution order is determined by dependencies specified in each file's YAML frontmatter. It supports running shell commands and LLM-driven tasks.\n\n*   **Plan Management**: A \"Plan\" is a directory of Markdown files that represents a task. The `flow plan` command includes subcommands to `init`, `add`, `run`, `status`, `graph`, and `finish` these plans. A terminal interface (`flow plan status -t`) is available for monitoring plan progress.\n\n*   **Chat Integration**: The `flow chat` command manages conversational logs with an LLM, stored as a single Markdown file. The `flow plan extract` command can then be used to convert sections of the conversation into executable jobs within a plan.\n\n*   **Recipes and Templates**: The `flow plan init --recipe` command creates a new plan from a predefined directory structure of job files. The `flow plan add --template` command creates a new job from a predefined Markdown file."
        },
        {
          "title": "How It Works",
          "content": "A \"Plan\" is a directory containing numbered Markdown files, where each file represents a \"Job\". Each job file contains YAML frontmatter that defines its `type` (`agent`, `oneshot`, `shell`), `status` (`pending`, `completed`), and dependencies via a `depends_on` key.\n\nThe orchestrator reads all job files in a plan directory, builds a dependency graph, and executes jobs whose dependencies have a `completed` status. Jobs of type `agent` or `interactive_agent` are executed within a Git worktree specified in the job's frontmatter, providing filesystem isolation."
        },
        {
          "title": "Ecosystem Integration",
          "content": "Grove Flow functions as a component of the Grove tool suite and executes other tools in the ecosystem as subprocesses.\n\n*   **Grove Context (`cx`)**: Before executing a job, `grove-flow` calls `grove-context` to read `.grove/rules` files and generate a file-based context. This context is then provided to the LLM.\n\n*   **Grove Hooks (`grove-hooks`)**: `grove-flow` emits events for job lifecycle stages (e.g., job start, completion, or failure). These events can be tracked by `grove-hooks` for monitoring and logging purposes."
        },
        {
          "title": "Installation",
          "content": "Install via the Grove meta-CLI:\n\nVerify installation:\n\nRequires the `grove` meta-CLI. See the [Grove Installation Guide](https://github.com/mattsolo1/grove-meta/blob/main/docs/02-installation.md) if you don't have it installed.",
          "code_blocks": [
            "grove install flow",
            "flow version"
          ]
        }
      ]
    },
    "recipes-and-templates": {
      "title": "Recipes and Templates",
      "content": "Grove Flow uses recipes for creating multi-job plans from a scaffold, and job templates for creating individual jobs from a blueprint.",
      "subsections": [
        {
          "title": "Job Templates",
          "content": "A job template is a Markdown file containing frontmatter and a prompt body. It serves as a blueprint for creating new, individual jobs.\n\n### Using a Job Template\n\nThe `flow plan add --template` command creates a new job file using the frontmatter and body from a specified template file.\n\n\nFlags like `--prompt` or `--source-files` provide additional content to the job being created from the template.\n\n### Listing Available Templates\n\nThe `flow plan templates list` command displays all available job templates from built-in, user-global (`~/.config/grove/job-templates/`), and project-specific (`.grove/job-templates/`) locations.\n\n\n\n### Creating Custom Job Templates\n\nJob templates are located in two directories, with project-specific templates overriding user-global ones:\n\n1.  **Project-specific**: `.grove/job-templates/` within a project root.\n2.  **User-global**: `~/.config/grove/job-templates/`.\n\nEach template is a Markdown file. The frontmatter defines default settings for the job, and the body serves as the base prompt.\n\n**Example: `.grove/job-templates/test-strategy.md`**\n\n\n### Built-in Job Templates\n\nGrove Flow includes several built-in templates.\n\n| Template Name            | Description                                        |\n| ------------------------ | -------------------------------------------------- |\n| `agent-run`              | Generates a plan an LLM agent carries out.         |\n| `agent-xml`              | Generates a detailed XML plan an LLM agent carries out. |\n| `api-design`             | Designs a RESTful or GraphQL API.                  |\n| `architecture-overview`  | Generates an architecture overview of a codebase.  |\n| `chat`                   | A template for conversational chat jobs.           |\n| `code-review`            | Performs a code review.                            |\n| `deployment-runbook`     | Creates a production deployment runbook.           |\n| `documentation`          | Updates project documentation.                     |\n| `generate-plan`          | Generates a multi-step plan from a specification.  |\n| `incident-postmortem`    | Analyzes an incident and creates action items.     |\n| `learning-guide`         | Creates a learning guide for a codebase.           |\n| `learning-lang`          | Creates a language learning guide from code.       |\n| `migration-plan`         | Plans a technology or database migration.          |\n| `performance-analysis`   | Analyzes and suggests optimizations for performance.|\n| `refactoring-plan`       | Plans a large-scale refactoring effort.            |\n| `refine-plan-generic`    | A generic template for refining a plan.            |\n| `security-audit`         | Conducts a security audit of a codebase.           |\n| `tech-debt-assessment`   | Assesses and prioritizes technical debt.           |\n| `test-strategy`          | Creates a test strategy.                           |",
          "code_blocks": [
            "# Add a new job using the 'code-review' template\nflow plan add --title \"Review API Endpoints\" --template code-review",
            "flow plan templates list",
            "NAME                   SOURCE     DESCRIPTION\nagent-run              [Built-in] Generates a plan an LLM agent carries out\napi-design             [Built-in] Design a RESTful or GraphQL API\n...\nmy-custom-template     [User]     A custom template for team-specific tasks",
            "---\ndescription: \"Create a test strategy\"\ntype: \"oneshot\"\nmodel: \"gemini-2.5-pro\"\n---\n\nDevelop a testing strategy for this feature. Analyze existing test patterns and consider the balance between unit, integration, and e2e tests."
          ]
        },
        {
          "title": "Plan Recipes",
          "content": "Plan recipes are directories containing a set of job files that define a multi-job workflow. They are used to scaffold new plans.\n\n### Using a Plan Recipe\n\nThe `flow plan init --recipe` command creates a new directory and populates it with the job files defined in the specified recipe.\n\n\nThis command creates the `plans/new-auth-feature` directory and populates it with jobs like `01-spec.md` and `02-implement.md` from the recipe.\n\n### Built-in Recipes\n\nGrove Flow provides several built-in recipes:\n\n-   **`standard-feature`**: A workflow for feature development: Spec -\u003e Implement -\u003e Git Status Checks -\u003e Review.\n-   **`chat-workflow`**: A workflow that starts with a `chat` job for exploration, followed by implementation and review.\n-   **`chat`**: A minimal plan containing only a single `chat` job. This is the default recipe for `flow plan init`.\n-   **`docgen-customize`**: A workflow for generating documentation: first a `chat` job to define the structure, then an `agent` job to write the content.\n\n### Creating Custom Recipes\n\nUser-defined recipes can be created by adding directories to `~/.config/grove/recipes/`. Each subdirectory is a recipe containing the `.md` job files that compose the plan.\n\n**Example Structure:**\n\n\nThis structure enables running `flow plan init my-project-release --recipe my-release-workflow`.",
          "code_blocks": [
            "# Initialize a plan using the standard-feature recipe\nflow plan init new-auth-feature --recipe standard-feature",
            "~/.config/grove/recipes/\n└── my-release-workflow/\n    ├── 01-update-changelog.md\n    ├── 02-run-tests.md\n    └── 03-tag-release.md"
          ]
        },
        {
          "title": "Templating in Recipes",
          "content": "Recipe files can contain template variables using Go's template syntax.\n\n### Standard Variables\n\n-   `{{ .PlanName }}`: This variable is replaced with the name of the plan being initialized.\n\n**Example: `01-spec.md` from the `standard-feature` recipe**\n\n\nWhen running `flow plan init new-login-flow --recipe standard-feature`, `{{ .PlanName }}` is replaced with `new-login-flow`.\n\n### Custom Variables\n\nThe `--recipe-vars` flag passes key-value pairs to a recipe. These are accessible via the `{{ .Vars.\u003ckey\u003e }}` syntax.\n\n-   **Passing Variables**:\n    -   Multiple flags: `--recipe-vars key1=val1 --recipe-vars key2=val2`\n    -   Comma-delimited: `--recipe-vars \"key1=val1,key2=val2\"`\n\n**Example: A recipe job `01-chat.md` using a custom `model` variable:**\n\n\n**Command to pass the variable:**\n\n\nDefault variables can be set for a recipe in `grove.yml`. CLI flags override `grove.yml` settings.",
          "code_blocks": [
            "---\nid: spec\ntitle: \"Specification for {{ .PlanName }}\"\nstatus: pending\ntype: oneshot\n---\n\nDefine the specification for the \"{{ .PlanName }}\" feature.",
            "---\ntitle: \"Chat about {{ .PlanName }}\"\ntype: chat\n{{ if .Vars.model }}model: \"{{ .Vars.model }}\"{{ end }}\n---\n\nLet's discuss the plan.",
            "flow plan init my-plan --recipe my-chat-recipe --recipe-vars model=gemini-2.5-pro",
            "# grove.yml\nflow:\n  recipes:\n    docgen-customize:\n      vars:\n        model: \"gemini-2.5-pro\"\n        rules_file: \"docs/docs.rules\""
          ]
        },
        {
          "title": "Dynamic Recipe Loading",
          "content": "Recipes can be loaded by executing an external command defined by `get_recipe_cmd` in `grove.yml`.\n\n\nThe command must output a JSON object where each key is a recipe name and the value is an object containing `description` and a `jobs` map.\n\n**Example JSON Output:**\n\n\nWhen a recipe name exists in multiple sources, the order of precedence is: **User** \u003e **Dynamic** \u003e **Built-in**.",
          "code_blocks": [
            "# grove.yml\nflow:\n  recipes:\n    get_recipe_cmd: \"my-cli-tool recipes --json\"",
            "{\n  \"company-microservice\": {\n    \"description\": \"Standard microservice template.\",\n    \"jobs\": {\n      \"01-setup.md\": \"---\\ntitle: Setup {{ .PlanName }}\\n---\\nSetup the service.\",\n      \"02-deploy.md\": \"---\\ntitle: Deploy {{ .PlanName }}\\n---\\nDeploy the service.\"\n    }\n  }\n}"
          ]
        }
      ]
    },
    "working-with-jobs": {
      "title": "Working with Jobs",
      "content": "Jobs are the fundamental units of work in a Grove Flow plan. Each job is a single, executable step defined in a Markdown file. This document covers how to create, configure, and manage these jobs to build effective workflows.",
      "subsections": [
        {
          "title": "Creating Jobs",
          "content": "The primary command for adding a new job to a plan is `flow plan add`. It can be used interactively through a Terminal User Interface (TUI) or non-interactively with flags.\n\n### Interactive Mode (TUI)\n\nRunning `flow plan add` or `flow plan add -i` launches an interactive form to guide you through creating a new job. This interface provides prompts and lists available options like job types, dependencies, and models.\n\n\nThe TUI allows you to set the job's title, type, prompt, dependencies, and other configurations in a structured way.\n\n### Flag-Based Mode\n\nFor scripting or quick additions, you can provide all job details using flags.\n\n**Example:**\n\nThis creates a new Markdown file (e.g., `02-implement-api-endpoints.md`) in the active plan directory with the specified frontmatter and prompt.\n\n**Key `plan add` Flags:**\n\n| Flag             | Alias | Description                                                                |\n| ---------------- | ----- | -------------------------------------------------------------------------- |\n| `--title`        |       | The title of the job.                                                      |\n| `--type`         | `-t`  | The job type (e.g., `agent`, `oneshot`, `shell`).                           |\n| `--depends-on`   | `-d`  | A job filename this new job depends on. Can be used multiple times.        |\n| `--prompt`       | `-p`  | The main prompt or command for the job, provided inline.                   |\n| `--prompt-file`  | `-f`  | Path to a file containing the prompt content.                              |\n| `--source-files` |       | Comma-separated list of files to include as context.                       |\n| `--template`     |       | The name of a job template to use.                                         |\n| `--worktree`     |       | The git worktree for the job to run in.                                    |\n| `--agent-continue` |     | For `agent` jobs, continue the previous agent session in the same worktree.|\n| `--interactive`  | `-i`  | Force the interactive TUI mode.                                            |\n\n### Writing Effective Prompts\n\n-   **Be Specific**: State the goal and constraints. Provide file paths, function names, and expected outcomes.\n-   **Provide Context**: Use `--source-files` or reference outputs from previous jobs to give the LLM the context it needs.\n-   **Structure for the Job Type**: An `agent` prompt should be a high-level task, while a `oneshot` prompt can be a more specific question. A `shell` prompt is simply the command to be executed.",
          "code_blocks": [
            "# If an active plan is set\nflow plan add\n\n# Or specify the plan directory\nflow plan add ./plans/my-feature -i",
            "# Set 'my-feature' as the active plan\nflow plan set my-feature\n\n# Add an agent job that depends on the initial spec\nflow plan add \\\n  --title \"Implement API Endpoints\" \\\n  --type \"agent\" \\\n  --depends-on \"01-spec.md\" \\\n  --prompt \"Implement the user API endpoints as defined in the spec.\""
          ]
        },
        {
          "title": "Job Types Explained",
          "content": "Grove Flow supports several job types, each with a specific purpose and executor.\n\n| Type                | Description                                                          | Use Case                                                              |\n| ------------------- | -------------------------------------------------------------------- | --------------------------------------------------------------------- |\n| `agent`             | An `interactive_agent` session for complex, multi-step coding tasks. | Implementing features, large-scale refactoring, debugging.            |\n| `interactive_agent` | The primary agent type; a human-in-the-loop session in `tmux`.       | Same as `agent`. `agent` is an alias for this type.                   |\n| `headless_agent`    | A non-interactive agent that runs in the background.                 | Fully automated code generation tasks in a CI/CD pipeline.            |\n| `oneshot`           | A single-shot LLM prompt for analysis, review, or generation.        | Code reviews, generating documentation, creating test plans.          |\n| `shell`             | Executes a shell command in the job's worktree or main repo.         | Running tests, linting, building code, or managing files.             |\n| `chat`              | A multi-turn conversational job for ideation and refinement.         | Brainstorming a feature before creating a formal plan.                |\n| `generate-recipe`   | Generates a reusable plan recipe from an existing plan.              | Automating the creation of standardized development workflows.        |"
        },
        {
          "title": "Dependencies Between Jobs",
          "content": "You can create workflows by defining dependencies between jobs. A job will not run until all of its dependencies have the status `completed`.\n\nDependencies are defined using the `depends_on` key in the job's frontmatter, which contains a list of the filenames of the jobs it depends on.\n\n**Example Frontmatter:**\n\nWhen using the CLI, you can specify dependencies with the `-d` or `--depends-on` flag:",
          "code_blocks": [
            "---\nid: review-code\ntitle: \"Review Code\"\nstatus: pending\ntype: oneshot\ndepends_on:\n  - 01-implement-feature.md\n  - 02-run-tests.md\n---",
            "flow plan add --title \"Review Code\" -d 01-implement-feature.md -d 02-run-tests.md"
          ]
        },
        {
          "title": "Models and LLM Configuration",
          "content": "You can control which LLM is used for a job at multiple levels, following a clear inheritance hierarchy:\n\n1.  **Job Level**: The `model` key in a job's frontmatter (`.md` file). This has the highest precedence.\n2.  **Plan Level**: The `model` key in the plan's `.grove-plan.yml` file. This sets the default for all jobs in that plan. You can manage this with `flow plan config set model \u003cmodel-id\u003e`.\n3.  **Project Level**: The `oneshot_model` key in your project's `grove.yml` file. This serves as the global default.\n\nUse the `flow models` command to see a list of recommended models."
        },
        {
          "title": "Job Templates",
          "content": "Templates allow you to reuse common job structures and prompts.\n\n-   **List Templates**: To see all available templates (project-local, user-global, and built-in), run:\n    ```bash\n    flow plan templates list\n    ```\n\n-   **Use a Template**: Apply a template when adding a new job using the `--template` flag.\n    ```bash\n    flow plan add --title \"Review API\" --template code-review\n    ```\n\nThis will create a new job with the pre-defined prompt and configuration from the `code-review` template. You can add your own instructions, which will be appended to the template's prompt.\n\n-   **Creating Custom Templates**: You can create your own templates by adding `.md` files to a `.grove/job-templates` directory in your project root."
        },
        {
          "title": "Job Completion and Management",
          "content": "-   **Manual Completion**: For jobs that require manual intervention or verification (like `interactive_agent` or `chat`), you can mark them as complete with:\n    ```bash\n    flow plan complete \u003cjob-file\u003e\n    ```\n    When an `interactive_agent` job is completed, Grove Flow will automatically find the `clogs` transcript from the session and append it to the job file for a complete record.\n\n-   **Automatic Summarization**: If `summarize_on_complete: true` is set in your `grove.yml`, Grove Flow will automatically generate a one-sentence summary of what the job accomplished and add it to the `summary` field in the job's frontmatter upon completion.\n\n-   **Job Output**: The output from `oneshot` and `shell` jobs is appended to the job's Markdown file under an `## Output` heading, providing a persistent log of its execution.\n\n-   **Debugging**: If a job fails, its status will be set to `failed`. The output and logs within the job file provide the necessary information to debug the issue. Once fixed, you can re-run the job with `flow plan run \u003cjob-file\u003e`."
        },
        {
          "title": "Advanced Topics",
          "content": "-   **Job Frontmatter**: The YAML frontmatter in each job file is the source of truth for its configuration. You can directly edit these files to modify any aspect of a job, such as its type, dependencies, or prompt.\n-   **Worktree Integration**: For `agent` and `shell` jobs, you can specify a `worktree` in the frontmatter. The job will execute within that git worktree, providing isolation from your main branch. If a dependent job is added, it will automatically inherit the worktree from its dependency unless specified otherwise."
        }
      ]
    }
  }
}