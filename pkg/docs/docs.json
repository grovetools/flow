{
  "sections": {
    "configuration": {
      "title": "Configuration",
      "content": "",
      "subsections": [
        {
          "title": "Flow Configuration",
          "content": "This section details the configuration properties available under the `flow` extension in a `grove.yml` file. These settings control the behavior of the Grove Flow orchestration engine, including default models, directory structures, and automation preferences.\n\n| Property | Description |\n| :--- | :--- |\n| `chat_directory` | (string, optional) \u003cbr\u003e Specifies the directory where chat-based job files are stored or looked up. This helps separate interactive chat sessions from formal orchestration plans. |\n| `max_consecutive_steps` | (integer, optional) \u003cbr\u003e Defines the safety limit for the maximum number of consecutive execution steps the orchestrator will take before pausing. This prevents infinite loops in autonomous agent workflows. |\n| `oneshot_model` | (string, optional) \u003cbr\u003e The default Language Model (LLM) to use for \"oneshot\" jobs (jobs that execute a single prompt without a conversational loop) if no specific model is defined in the job itself. |\n| `plans_directory` | (string, optional) \u003cbr\u003e The root directory where Grove searches for orchestration plans. When running `flow plan list` or executing a plan by name, the system looks here. |\n| `recipes` | (object, optional) \u003cbr\u003e A configuration object for defining custom plan recipes or overrides for existing ones. |\n| `run_init_by_default` | (boolean, optional) \u003cbr\u003e Controls whether the initialization actions defined in a recipe should execute automatically when a plan is created. If set to `false`, the user must manually trigger initialization. |\n| `summarize_on_complete` | (boolean, optional) \u003cbr\u003e If set to `true`, the system will automatically generate a summary of the job's output using an LLM upon successful completion and append it to the job file. |\n| `summary_max_chars` | (integer, optional) \u003cbr\u003e The maximum character length for the automatically generated summary. Useful for keeping summaries concise for display in lists. |\n| `summary_model` | (string, optional) \u003cbr\u003e The specific LLM model to use when generating summaries. This allows you to use a cheaper or faster model for summarization than the one used for the main task. |\n| `summary_prompt` | (string, optional) \u003cbr\u003e A custom prompt template used to instruct the LLM on how to summarize the job output. |\n| `target_agent_container` | (string, optional) \u003cbr\u003e Specifies the default Docker container or environment where agent jobs should be executed. Useful for isolating agent execution environments. |",
          "code_blocks": [
            "[flow]\nplans_directory = \"./plans\"\noneshot_model = \"claude-3-5-sonnet-20240620\"\nsummarize_on_complete = true\nmax_consecutive_steps = 25\ntarget_agent_container = \"grove-agent-v1\""
          ]
        },
        {
          "title": "Job Schema",
          "content": "This section describes the schema for Grove Flow jobs. These properties are typically found in the YAML frontmatter of Markdown files (`.md`) within a plan directory. They define the job's identity, execution parameters, dependencies, and state.\n\n| Property | Description |\n| :--- | :--- |\n| `Dependencies` | (array, optional) \u003cbr\u003e **System Managed.** An internal list of resolved dependency objects. Users should generally configure `depends_on` instead. |\n| `EndTime` | (string, optional) \u003cbr\u003e **System Managed.** The timestamp recording when the job execution finished. |\n| `Filename` | (string, optional) \u003cbr\u003e **System Managed.** The name of the file containing this job. |\n| `FilePath` | (string, optional) \u003cbr\u003e **System Managed.** The full filesystem path to the job file. |\n| `PromptBody` | (string, optional) \u003cbr\u003e **System Managed.** The textual content of the job (everything below the frontmatter), which serves as the primary prompt or instruction. |\n| `StartTime` | (string, optional) \u003cbr\u003e **System Managed.** The timestamp recording when the job execution began. |\n| `branch` | (string, optional) \u003cbr\u003e Specifies the git branch context in which this job should operate. |\n| `completed_at` | (string, optional) \u003cbr\u003e **System Managed.** The timestamp marking successful completion. |\n| `created_at` | (string, optional) \u003cbr\u003e **System Managed.** The timestamp marking when the job was created. |\n| `depends_on` | (array of strings, optional) \u003cbr\u003e A list of job IDs or filenames that this job depends on. This job will not execute until all listed dependencies have successfully completed. |\n| `duration` | (integer, optional) \u003cbr\u003e **System Managed.** The duration of the job execution in nanoseconds. |\n| `gather_concept_notes` | (boolean, optional) \u003cbr\u003e If `true`, the job will attempt to gather related notes from the knowledge base (concepts) and include them in the context. |\n| `gather_concept_plans` | (boolean, optional) \u003cbr\u003e If `true`, the job will attempt to gather related plans from the knowledge base and include them in the context. |\n| `generate_plan_from` | (boolean, optional) \u003cbr\u003e Indicates that this job is intended to generate a new execution plan based on the output of its dependencies. |\n| `git_changes` | (boolean, optional) \u003cbr\u003e If `true`, the current git diff/changes will be included in the context provided to the agent or LLM. |\n| `id` | (string, optional) \u003cbr\u003e A unique identifier for the job. Used for dependency resolution and referencing. |\n| `include` | (array of strings, optional) \u003cbr\u003e A list of file paths to include as context for this job. |\n| `model` | (string, optional) \u003cbr\u003e The LLM model to use for this specific job, overriding any global or plan-level defaults. |\n| `note_ref` | (string, optional) \u003cbr\u003e A reference to a specific note (e.g., in a PKM system) associated with this job. |\n| `on_complete_status` | (string, optional) \u003cbr\u003e Defines a status to set or an action to take when the job completes. |\n| `prepend_dependencies` | **Deprecated** (boolean, optional) \u003cbr\u003e Formerly used to inline dependency outputs. Please use the `inline` object with `Categories: [\"dependencies\"]` instead. |\n| `recipe_name` | (string, optional) \u003cbr\u003e The name of the recipe used if this job was generated from one. |\n| `repository` | (string, optional) \u003cbr\u003e Specifies the target git repository for this job. |\n| `rules_file` | (string, optional) \u003cbr\u003e Path to a specific rules file that governs context inclusion for this job. |\n| `source_block` | (string, optional) \u003cbr\u003e Used to target a specific block of text from a source file (e.g., `filename.md#block-id`) to use as the prompt. |\n| `source_file` | (string, optional) \u003cbr\u003e The path to the source file if this job was generated or extracted from another document. |\n| `source_plan` | (string, optional) \u003cbr\u003e The name of the plan this job belongs to or originated from. |\n| `status` | (string, optional) \u003cbr\u003e The current state of the job. Common values include `pending`, `running`, `completed`, `failed`. |\n| `summary` | (string, optional) \u003cbr\u003e **System Managed.** An automatically generated summary of the job's execution results. |\n| `target_agent_container` | (string, optional) \u003cbr\u003e Overrides the global agent container setting for this specific job. |\n| `template` | (string, optional) \u003cbr\u003e The name of a template to use for rendering the job's prompt structure. |\n| `title` | (string, optional) \u003cbr\u003e A human-readable title for the job. |\n| `type` | (string, optional) \u003cbr\u003e The type of job (e.g., `oneshot`, `agent`, `chat`, `interactive_agent`). |\n| `updated_at` | (string, optional) \u003cbr\u003e **System Managed.** The timestamp of the last update to the job file. |\n| `worktree` | (string, optional) \u003cbr\u003e The specific git worktree directory to use for this job's execution context. |\n\n### Metadata\n\nThis object contains execution statistics and error details, typically managed by the system.\n\n| Property | Description |\n| :--- | :--- |\n| `execution_time` | (integer, required) \u003cbr\u003e The time taken to execute the job. |\n| `last_error` | (string, required) \u003cbr\u003e The error message if the last execution failed. |\n| `retry_count` | (integer, required) \u003cbr\u003e The number of times this job has been retried. |\n\n### inline\n\nConfiguration for what content should be directly embedded (inlined) into the prompt context.\n\n| Property | Description |\n| :--- | :--- |\n| `Categories` | (array of strings, required) \u003cbr\u003e A list of category names to inline. Common values include `\"dependencies\"` (outputs of upstream jobs), `\"include\"` (content of included files), or `\"context\"` (project context). |",
          "code_blocks": [
            "title = \"Implement User Auth\"\ntype = \"agent\"\nstatus = \"pending\"\ndepends_on = [\"01-design-auth.md\"]\nworktree = \"feat/user-auth\"\nmodel = \"claude-3-5-sonnet\"\n[inline]\nCategories = [\"dependencies\", \"include\"]"
          ]
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`flow` is a command-line tool that orchestrates LLM-assisted development workflows. It manages the lifecycle of \"plans\"—directories of Markdown files defining distinct jobs—and executes them within isolated Git worktrees.",
      "subsections": [
        {
          "title": "Core Mechanisms",
          "content": "**Plan Structure**: A plan is a directory containing numbered Markdown files (e.g., `01-spec.md`, `02-impl.md`). Each file represents a \"job\" and contains YAML frontmatter defining properties like `type`, `model`, and `depends_on`.\n\n**Orchestration**: The tool reads the plan directory, builds an in-memory dependency graph, and executes runnable jobs.\n*   **Briefing**: Before execution, it assembles an XML prompt containing system instructions, dependency outputs, and repository context.\n*   **Audit Trail**: Outputs (LLM responses, agent transcripts) are appended directly to the source Markdown file, preserving the history in version control.\n\n**Worktree Isolation**: Jobs can specify a `worktree`. `flow` creates these in `.grove-worktrees/` at the project root, allowing agents to modify code without affecting the main working directory."
        },
        {
          "title": "Features",
          "content": "### Job Types\n*   **`chat`**: Interactive, multi-turn conversations stored in a single file.\n*   **`oneshot`**: Single-turn requests that complete immediately.\n*   **`interactive_agent`**: Launches an agent (Claude Code, OpenCode, Codex) in a dedicated `tmux` window.\n*   **`headless_agent`**: Non-interactive agent execution that completes after going idle.\n*   **`shell`**: Executes system shell commands.\n\n### Dependency Management\nJobs declare dependencies via the `depends_on` field. The orchestrator ensures jobs run in topological order and passes context from dependencies to dependent jobs.\n\n### Terminal Interfaces (TUI)\n*   **`flow status`**: Displays the plan's dependency tree and streams live logs from running agents.\n*   **`flow plan tui`**: A browser for managing multiple plans and merging worktrees.\n*   **`flow plan init`**: An interactive wizard for creating plans.\n\n### Templates \u0026 Recipes\n*   **Templates**: Reusable Markdown files defining job structures and prompts.\n*   **Recipes**: Predefined collections of jobs that scaffold entire plans (e.g., \"Feature Implementation\")."
        },
        {
          "title": "Integrations",
          "content": "*   **`hooks`**: Registers running agent sessions to track process liveness and status.\n*   **`cx`**: Used to generate repository context files based on `.grove/rules`.\n*   **`nav`**: Integrates with Grove Navigation for `tmux` session management.\n*   **LLM Providers**: Supports Anthropic and Gemini models via `grove-anthropic` and `grove-gemini`. Uses native file upload APIs for handling large context."
        }
      ]
    },
    "quick-start": {
      "title": "Quick Start",
      "content": "This document provides a complete example of using `flow` to manage a multi-step workflow.",
      "subsections": [
        {
          "title": "Prerequisites",
          "content": "Before starting, ensure `flow` is installed and API keys are configured. For detailed instructions, see the [Grove installation guide](/docs/overview/03-installation).\n\nA summary of prerequisites:\n*   `grove install flow`: Installs the `flow` binary.\n*   `grove setup`: Configures API keys for either Gemini or Anthropic models.\n*   A git repository to serve as the working project.\n\nThe workflow described uses models and features that are tested with Anthropic's Claude and Google's Gemini models. Support for other models like `codex` or `opencode` is experimental."
        },
        {
          "title": "Example: Implementing a Feature with the Chef-Cook-Critic Recipe",
          "content": "This example demonstrates a full workflow lifecycle by creating and executing a plan to make a grilled cheese sandwich. It uses a built-in recipe called `chef-cook-critic` that defines a sequence of jobs with different roles (personas).\n\n### Step 1: Initialize a Plan\n\nA plan is created using `flow plan init`. This command launches a terminal interface to configure the new plan. The following example creates a plan named `grilled-cheese-sandwich` based on the `chef-cook-critic` recipe, with an associated git worktree for isolation.\n\n\n./videos/01-plan-init.mp4\n\n/Users/solom4/Code/grovetools/flow/docs/videos/01-plan-init.mp4\n\n![Plan Init Video](./videos/01-plan-init.mp4#themed)\n\nThis creates a directory named `grilled-cheese-sandwich/` containing a series of job files (`.md`) that form a dependency chain. The `flow status` command displays this chain in its terminal interface.\n\n\n### Understanding Briefing Files (What Agents Receive)\n\nEach job generates a briefing XML file that is sent to the LLM. This file contains:\n\n*   System instructions derived from a template.\n*   Context files gathered from the repository.\n*   The job's prompt or the current state of a conversation.\n\nThe `template` field in a job's frontmatter determines which system instructions are included in the briefing's `\u003csystem_instructions\u003e` tag. The agent reads this file to get its task.\n\nBelow is an example of a briefing file generated from a `chef` template:\n\n\n### Step 2a: Run a Chat Job\n\nA `oneshot` job can be converted to a `chat` job by changing the `type` field in its frontmatter. This allows for multi-turn conversations with the LLM. The `flow run \u003cfile\u003e` command (or a text editor integration) executes the next turn in the chat.\n\n\nThe LLM's response is appended to the markdown file. The conversation can be continued by adding more user text and re-running the command, or it can be marked as complete from the `flow status` interface.\n\n\n### Step 2b: Add a Dynamic Feedback Job\n\nNew jobs can be added to a running plan using the `flow add` command, which provides a terminal interface for defining the new job's properties, such as its title, type, and dependencies.\n\n\nThe `flow status` interface has a column visibility toggle (`T`) to customize the display. When a job is run, log output and token usage information are displayed.\n\n\nThe token usage panel shows a breakdown of cached context (`Cold`), uncached context (`Hot`), and the user prompt, along with API response time and cost estimates.\n\n\n### Step 3: Run an Interactive Agent\n\nA `headless_agent` job runs autonomously. Changing its type to `interactive_agent` (using the `Y` key in the `flow status` TUI) will cause it to launch in an interactive `tmux` session.\n\n\nThe agent's log output streams into the `flow status` interface. The full transcript of the interactive session is preserved in the job's markdown file after completion.\n\n### Step 4: Execute the Rest of the Plan\n\nMultiple jobs can be selected in the status TUI and run in sequence by pressing `r`. The interface displays the progress through the dependency graph. The logs for any job, including `headless_agent` jobs, can be viewed in the detail pane.\n\n\nThe final output of a job is appended to its markdown file.\n\n### Step 5: Explore the Notebook Artifacts\n\nAll artifacts generated during a plan's execution, including briefing files, logs, and agent transcripts, are stored in a `.artifacts/` subdirectory within the plan's directory. These artifacts can be browsed using the `nb` notebook TUI.\n\n\nThe agent transcript is appended to the body of the corresponding job's markdown file, providing a record of the agent's actions.\n\n### Step 6: Commit and Merge Work\n\nChanges made by agents within a git worktree can be viewed using `gmux sz`. The `flow status` TUI indicates if a worktree is \"dirty\" (has uncommitted changes) and will not allow it to be merged.\n\n\nAfter committing changes, the worktree is \"clean\" and can be merged into the main branch by pressing `M` in the status TUI. The git log confirms the merge.\n\n### Step 7: Clean Up (Optional)\n\nAfter a plan is complete and the work is merged, the `flow finish` command or the `C-x` keybinding in the status TUI can be used to clean up associated resources, such as deleting the git worktree and branch.\n\n\n### What Just Happened\n\nThis example demonstrated a workflow that:\n1.  Created a plan from a recipe with an isolated git worktree.\n2.  Executed a sequence of seven jobs according to a dependency graph.\n3.  Utilized multiple job types: `chat` for conversation, `oneshot` for single LLM calls, `headless_agent` for autonomous execution, and `interactive_agent` for user collaboration.\n4.  Preserved all generated artifacts, including briefings and transcripts, for auditing and debugging.\n5.  Managed the lifecycle of the worktree from creation to merge and cleanup.\n\nKey concepts demonstrated:\n*   **Templates**: Define agent personas and system instructions within briefing XML files.\n*   **Dependencies**: Control the execution order of jobs in a directed acyclic graph (DAG).\n*   **TUI**: Provides real-time visibility into job status, logs, and git state.\n*   **Artifacts**: All inputs and outputs are stored for reproducibility and review.",
          "code_blocks": [
            "{\n  \"src\": \"./asciicasts/01-plan-init.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/01-plan-init-status.cast\"\n}",
            "\u003cprompt\u003e\n\u003csystem_instructions\u003e\nwhen prompted with a food, write an amazing recipe for the cook to execute.\n\nif a critic gives you feedback, write a new recipe version with the suggestions but act annoyed about it.\n\n\u003c/system_instructions\u003e\n\n\u003cconversation_note\u003e\nThis is a multi-turn conversation. Focus on the turn marked status=\"awaiting_response\" -\nthat is the message requiring your reply. The respond_as attribute indicates what persona\nto use. Previous responses may have been generated by different prompts or personas;\ninterpret and continue through YOUR current system instructions.\n\u003c/conversation_note\u003e\n\n\u003ccontext\u003e\n    \u003cuploaded_context_file file=\"context\" type=\"repository\" importance=\"medium\" description=\"Concatenated project/source code files from the current repository.\"/\u003e\n\u003c/context\u003e\n\n\u003cconversation\u003e\n  \u003cturn role=\"user\" status=\"awaiting_response\"\u003e\n    Today's food is grilled-cheese-sandwich\n\n    Make sure to use gouda!\n  \u003c/turn\u003e\n\u003c/conversation\u003e\n\u003c/prompt\u003e",
            "{\n  \"src\": \"./asciicasts/02a-chat-job.cast\"\n}",
            "\u003c!-- grove: {\"id\": \"1b3047\"} --\u003e\n## LLM Response (2026-01-13 08:08:53)\n\nAlright, a \"grilled-cheese-sandwich,\" you say? And you *insist* on gouda. Fine. Prepare yourself for something beyond your wildest dairy-induced dreams. This isn't just a grilled cheese; it's an experience.\n\n## The Elysian Gouda Grill\n\n**Yields:** 1 sublime sandwich\n**Prep time:** 5 minutes\n**Cook time:** 8-10 minutes\n\n...etc...",
            "{\n  \"src\": \"./asciicasts/02b-add-job.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/02b-add-job-run.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/02b-add-job-tokens.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/03-interactive-agent.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/04-execute-plan.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/05-notebook-artifacts.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/06-commit-merge.cast\"\n}",
            "{\n  \"src\": \"./asciicasts/07-cleanup.cast\"\n}"
          ]
        }
      ]
    }
  }
}